{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"8 888888888o. ,o888888o. 8 888888888o. 8 888888888888 8 8888 `^888. . 8888 `88. 8 8888 `88. 8 8888 8 8888 `88. ,8 8888 `8b 8 8888 `88 8 8888 8 8888 `88 88 8888 `8b 8 8888 ,88 8 8888 8 8888 88 88 8888 88 8 8888. ,88' 8 888888888888 8 8888 88 88 8888 88 8 888888888P' 8 8888 8 8888 ,88 88 8888 ,8P 8 8888`8b 8 8888 8 8888 ,88' `8 8888 ,8P 8 8888 `8b. 8 8888 8 8888 ,o88P' ` 8888 ,88' 8 8888 `8b. 8 8888 8 888888888P' `8888888P' 8 8888 `88. 8 888888888888 SYNTHETIC DATA GENERATOR Getting Started Dore is a tool that can generate fake data for you for schemas with complex dependencies; such as schemas with hierarchical relations, PK/FK relations, nested values, and so on. All you need to do is provide a single input which is a specification of the target data requirements and Dore generates the required databases, tables, and data for those tables for you. This input is known as the Manifest . Once the manifest is created, it can be shared with others in order to help them generate the same data as well! Dore leverages fake data generation libraries (ex: Faker), which allow you to generate fake values for certain data types, and generates fake data for entire schemas. Installation Install the dore package with pip . $ pip install dore Usage $ dore --manifest MANIFEST_FILE [ OPTIONS ] Next Steps Once the installation is complete, and if this is the first time you're trying out Dore, we recommend you check out our Tutorial which walks you through using Dore to generate fake data for the ecommerce schema shown below: Ecommerce schema Documentation CLI Reference : to view details on usage of dore command. Manifest Reference : to view documentation on Dore Manifest.","title":"Getting Started"},{"location":"#getting-started","text":"Dore is a tool that can generate fake data for you for schemas with complex dependencies; such as schemas with hierarchical relations, PK/FK relations, nested values, and so on. All you need to do is provide a single input which is a specification of the target data requirements and Dore generates the required databases, tables, and data for those tables for you. This input is known as the Manifest . Once the manifest is created, it can be shared with others in order to help them generate the same data as well! Dore leverages fake data generation libraries (ex: Faker), which allow you to generate fake values for certain data types, and generates fake data for entire schemas.","title":"Getting Started"},{"location":"#installation","text":"Install the dore package with pip . $ pip install dore","title":"Installation"},{"location":"#usage","text":"$ dore --manifest MANIFEST_FILE [ OPTIONS ]","title":"Usage"},{"location":"#next-steps","text":"Once the installation is complete, and if this is the first time you're trying out Dore, we recommend you check out our Tutorial which walks you through using Dore to generate fake data for the ecommerce schema shown below: Ecommerce schema","title":"Next Steps"},{"location":"#documentation","text":"CLI Reference : to view details on usage of dore command. Manifest Reference : to view documentation on Dore Manifest.","title":"Documentation"},{"location":"about/about/","text":"About What is Dore? Simply put, Dore is a fake data generation tool. Why is it called Dore? No particular reason. I just wanted to share my thoughts on how we should have spelt door . What can you do with it? Dore allows you to define the details of your target data in a config file, known as the Manifest , and Dore takes care of generating this data for you. With Dore, you can: Generate fake data for multiple models across multiple protocols with complex schemas with just a single command . For example, you can set up your entire database with data for all tables with FK/PK integrity constraints in a single command. Generate fake data with dependencies/hierarchy between models regardless of the protocol . For example, you can have a column in a MySQL table be dependent/have a FK relationship on a field in an Elasticsearch index. Support for generating data for attributes that are nested to arbitrary depth . Nested attributes can in turn be dependent or have their values derived from attributes of models in other protocols. For example, you can have a MongoDB collection which has a field that derives its value from a row of a PostgreSQL table or another MongoDB collection's doc.","title":"About"},{"location":"about/about/#about","text":"","title":"About"},{"location":"about/about/#what-is-dore","text":"Simply put, Dore is a fake data generation tool.","title":"What is Dore?"},{"location":"about/about/#why-is-it-called-dore","text":"No particular reason. I just wanted to share my thoughts on how we should have spelt door .","title":"Why is it called Dore?"},{"location":"about/about/#what-can-you-do-with-it","text":"Dore allows you to define the details of your target data in a config file, known as the Manifest , and Dore takes care of generating this data for you. With Dore, you can: Generate fake data for multiple models across multiple protocols with complex schemas with just a single command . For example, you can set up your entire database with data for all tables with FK/PK integrity constraints in a single command. Generate fake data with dependencies/hierarchy between models regardless of the protocol . For example, you can have a column in a MySQL table be dependent/have a FK relationship on a field in an Elasticsearch index. Support for generating data for attributes that are nested to arbitrary depth . Nested attributes can in turn be dependent or have their values derived from attributes of models in other protocols. For example, you can have a MongoDB collection which has a field that derives its value from a row of a PostgreSQL table or another MongoDB collection's doc.","title":"What can you do with it?"},{"location":"attribute_value_generators/composite/","text":"Composite Manifest path: $.models[*].attributes[*].value The composite attribute value generator is similar to the ref attribute value generator in the sense that you can have attributes of a model be dependent on other models. But, it is different in one major way: While you would use the ref attribute value generator when you want values of an attribute of a particular model be dependent on the values of another attribute of a different model, the composite attribute value generator lets you assign the value of an attribute to be an entire record of the dependent model. Example Consider the following schema where you want to generate records for a customer collection in MongoDB Fig: Schema with nested attribute The first model / collection customer has a shippingAddress field whose values are nested objects of the address model. That is, the documents in customer collection would look something like the one shown below: Dcouments in customer collection 1 2 3 4 5 6 7 8 9 { \"customer_id\" : 1 , \"shippingAddress\" : { \"house\" : \"foo house\" , \"street\" : \"bar street\" , \"state\" : \"baz state\" , \"country\" : \"Some Country } } In order to generate data for this schema with Dore, we can specify the value config for shippingAddress in the customer model as a composite value and provide a ref to the dependent model, which is the address model. Composite value config for `customer` model 1 2 3 4 5 6 7 { \"value\" : { \"composite\" : { \"ref\" : \"address\" } } } When an attribute uses a composite value generator, an entire record of the dependent model would be used as the value for the attribute. In other words, the attribute will have an object as a value and the value is a record of the dependent model. Fields composite (object)[required] Manifest path: $.models[*].attributes[*].value.composite.composite The composite object inside value config indicates Dore that it needs to use Composite Value Geneartor to generate values for the attribute. ref (string) [required] Manifest path: $.models[*].attributes[*].value.composite.ref Use ID of the referenced model as values here. A record of the referenced model (picked at random) will be used as value for this attribute.","title":"Composite"},{"location":"attribute_value_generators/composite/#composite","text":"Manifest path: $.models[*].attributes[*].value The composite attribute value generator is similar to the ref attribute value generator in the sense that you can have attributes of a model be dependent on other models. But, it is different in one major way: While you would use the ref attribute value generator when you want values of an attribute of a particular model be dependent on the values of another attribute of a different model, the composite attribute value generator lets you assign the value of an attribute to be an entire record of the dependent model.","title":"Composite"},{"location":"attribute_value_generators/composite/#example","text":"Consider the following schema where you want to generate records for a customer collection in MongoDB Fig: Schema with nested attribute The first model / collection customer has a shippingAddress field whose values are nested objects of the address model. That is, the documents in customer collection would look something like the one shown below: Dcouments in customer collection 1 2 3 4 5 6 7 8 9 { \"customer_id\" : 1 , \"shippingAddress\" : { \"house\" : \"foo house\" , \"street\" : \"bar street\" , \"state\" : \"baz state\" , \"country\" : \"Some Country } } In order to generate data for this schema with Dore, we can specify the value config for shippingAddress in the customer model as a composite value and provide a ref to the dependent model, which is the address model. Composite value config for `customer` model 1 2 3 4 5 6 7 { \"value\" : { \"composite\" : { \"ref\" : \"address\" } } } When an attribute uses a composite value generator, an entire record of the dependent model would be used as the value for the attribute. In other words, the attribute will have an object as a value and the value is a record of the dependent model.","title":"Example"},{"location":"attribute_value_generators/composite/#fields","text":"","title":"Fields"},{"location":"attribute_value_generators/composite/#composite-objectrequired","text":"Manifest path: $.models[*].attributes[*].value.composite.composite The composite object inside value config indicates Dore that it needs to use Composite Value Geneartor to generate values for the attribute.","title":"composite (object)[required]"},{"location":"attribute_value_generators/composite/#ref-string-required","text":"Manifest path: $.models[*].attributes[*].value.composite.ref Use ID of the referenced model as values here. A record of the referenced model (picked at random) will be used as value for this attribute.","title":"ref (string) [required]"},{"location":"attribute_value_generators/faker/","text":"Faker Manifest path: $.models[*].attributes[*].value With Dore, you can leverage the capabilities that Python's Faker library provides in order to generate values for attributes. Example Faker value config example 1 2 3 4 5 6 7 8 { \"faker\" : { \"pyint\" : { \"min_value\" : 1 , \"max_value\" : 3 } } } This is identical to invoking the pyint method for generating values for the attribute. Python's Faker library uses the concept of providers which provide methods to a faker instance. These methods, when invoked, generate a value. Fields faker (object) [required] Manifest path: $.models[*].attributes[*].value.faker The faker object inside value config indicates Dore that it needs to use Faker to generate values for the attribute. In a Dore manifest, Faker based attribute value configs have the following general structure: General structure of a faker config 1 2 3 4 5 6 7 8 9 { \"value\" : { // (1) \"faker\" : { // (2) \"faker_method_name\" : { // (3) ... fa ker me t hod params ... } } } } value config for the attribute at $.models[*].attributes[*].value Use \"faker\" to indicate that we want to use the faker value generator The faker method to use. Example: pyint , uuid4 , etc.","title":"Faker"},{"location":"attribute_value_generators/faker/#faker","text":"Manifest path: $.models[*].attributes[*].value With Dore, you can leverage the capabilities that Python's Faker library provides in order to generate values for attributes.","title":"Faker"},{"location":"attribute_value_generators/faker/#example","text":"Faker value config example 1 2 3 4 5 6 7 8 { \"faker\" : { \"pyint\" : { \"min_value\" : 1 , \"max_value\" : 3 } } } This is identical to invoking the pyint method for generating values for the attribute. Python's Faker library uses the concept of providers which provide methods to a faker instance. These methods, when invoked, generate a value.","title":"Example"},{"location":"attribute_value_generators/faker/#fields","text":"","title":"Fields"},{"location":"attribute_value_generators/faker/#faker-object-required","text":"Manifest path: $.models[*].attributes[*].value.faker The faker object inside value config indicates Dore that it needs to use Faker to generate values for the attribute. In a Dore manifest, Faker based attribute value configs have the following general structure: General structure of a faker config 1 2 3 4 5 6 7 8 9 { \"value\" : { // (1) \"faker\" : { // (2) \"faker_method_name\" : { // (3) ... fa ker me t hod params ... } } } } value config for the attribute at $.models[*].attributes[*].value Use \"faker\" to indicate that we want to use the faker value generator The faker method to use. Example: pyint , uuid4 , etc.","title":"faker (object) [required]"},{"location":"attribute_value_generators/random_selector/","text":"Random Selector Manifest path: $.models[*].attributes[*].value.selector Select values at random for the attribute from a list of values. Example Random selector example 1 2 3 4 5 6 7 8 9 10 11 { \"selector\" : { \"random\" : { \"items\" : [ \"S\" , \"M\" , \"L\" ] } } } An item from the items array is picked at random during each record generation for the attribute value. Fields random (object) Manifest path: $.models[*].attributes[*].value.selector.random The random object inside selector config indicates Dore that it needs to use the Random Selector to generate values for the attribute. items (array) [required] Manifest path: $.models[*].attributes[*].value.selector.random.items List of values to select from. An item can be a number, a string, or an arbitrarily complex JSON object. Each value in the list is usually equally likely to be picked.","title":"Random Selector"},{"location":"attribute_value_generators/random_selector/#random-selector","text":"Manifest path: $.models[*].attributes[*].value.selector Select values at random for the attribute from a list of values.","title":"Random Selector"},{"location":"attribute_value_generators/random_selector/#example","text":"Random selector example 1 2 3 4 5 6 7 8 9 10 11 { \"selector\" : { \"random\" : { \"items\" : [ \"S\" , \"M\" , \"L\" ] } } } An item from the items array is picked at random during each record generation for the attribute value.","title":"Example"},{"location":"attribute_value_generators/random_selector/#fields","text":"","title":"Fields"},{"location":"attribute_value_generators/random_selector/#random-object","text":"Manifest path: $.models[*].attributes[*].value.selector.random The random object inside selector config indicates Dore that it needs to use the Random Selector to generate values for the attribute.","title":"random (object)"},{"location":"attribute_value_generators/random_selector/#items-array-required","text":"Manifest path: $.models[*].attributes[*].value.selector.random.items List of values to select from. An item can be a number, a string, or an arbitrarily complex JSON object. Each value in the list is usually equally likely to be picked.","title":"items (array) [required]"},{"location":"attribute_value_generators/ref/","text":"Ref Manifest path: $.models[*].attributes[*].value Dore allows you to define values of an attribute as being dependent on values on other attributes. Often times, we would want the value of an attribute to be based on the value of an attribute of a different model. A typical scenario where we might want do this is while generating data in a relational database with Foreign Key dependencies. Before Dore starts generating records for any model, it analyzes the attribute and model dependencies and creates an iteration order over the models based on topological sorting of their dependencies. By doing this, Dore ensures that records for a model which has other models dependent on it are generated before generating records for the dependent models. Example You can consider the E-Commerce schema to understand this better. Ecommerce schema In order to generate data for this schema with Dore, we can specify the value config for customer_id in the Ecommerce.Order model as a ref value and provide a reference to the dependent attribute and model, which is the customer_id attribute of the Ecommerce.Customer model like so: Value config for the Ecommerce.Order attribute 1 2 3 4 5 { \"value\" : { \"ref\" : \"Customer.customer_id\" } } Fields ref (string) [required] Manifest path: $.models[*].attributes[*].value.ref A string of the form: modelId.attributeId which specifies the model and attribute ID on which the current attribute's value is dependent / derived from.","title":"Ref"},{"location":"attribute_value_generators/ref/#ref","text":"Manifest path: $.models[*].attributes[*].value Dore allows you to define values of an attribute as being dependent on values on other attributes. Often times, we would want the value of an attribute to be based on the value of an attribute of a different model. A typical scenario where we might want do this is while generating data in a relational database with Foreign Key dependencies. Before Dore starts generating records for any model, it analyzes the attribute and model dependencies and creates an iteration order over the models based on topological sorting of their dependencies. By doing this, Dore ensures that records for a model which has other models dependent on it are generated before generating records for the dependent models.","title":"Ref"},{"location":"attribute_value_generators/ref/#example","text":"You can consider the E-Commerce schema to understand this better. Ecommerce schema In order to generate data for this schema with Dore, we can specify the value config for customer_id in the Ecommerce.Order model as a ref value and provide a reference to the dependent attribute and model, which is the customer_id attribute of the Ecommerce.Customer model like so: Value config for the Ecommerce.Order attribute 1 2 3 4 5 { \"value\" : { \"ref\" : \"Customer.customer_id\" } }","title":"Example"},{"location":"attribute_value_generators/ref/#fields","text":"","title":"Fields"},{"location":"attribute_value_generators/ref/#ref-string-required","text":"Manifest path: $.models[*].attributes[*].value.ref A string of the form: modelId.attributeId which specifies the model and attribute ID on which the current attribute's value is dependent / derived from.","title":"ref (string) [required]"},{"location":"attribute_value_generators/round_robin_selector/","text":"Round Robin Selector Manifest path: $.models[*].attributes[*].value.selector Select values in a round-robin manner for the attribute from a list of values. Example Round Robin selector example 1 2 3 4 5 6 7 8 9 10 11 { \"selector\" : { \"roundRobin\" : { \"items\" : [ \"S\" , \"M\" , \"L\" ] } } } An item from the items array is picked in a round robin manner during each record generation for the attribute value. Fields roundRobin (object) Manifest path: $.models[*].attributes[*].value.selector.roundRobin The roundRobin object inside selector config indicates Dore that it needs to use the Random Selector to generate values for the attribute. items (array) [required] Manifest path: $.models[*].attributes[*].value.selector.roundRobin.items List of values to select from. An item can be a number, a string, or an arbitrarily complex JSON object.","title":"Round Robin Selector"},{"location":"attribute_value_generators/round_robin_selector/#round-robin-selector","text":"Manifest path: $.models[*].attributes[*].value.selector Select values in a round-robin manner for the attribute from a list of values.","title":"Round Robin Selector"},{"location":"attribute_value_generators/round_robin_selector/#example","text":"Round Robin selector example 1 2 3 4 5 6 7 8 9 10 11 { \"selector\" : { \"roundRobin\" : { \"items\" : [ \"S\" , \"M\" , \"L\" ] } } } An item from the items array is picked in a round robin manner during each record generation for the attribute value.","title":"Example"},{"location":"attribute_value_generators/round_robin_selector/#fields","text":"","title":"Fields"},{"location":"attribute_value_generators/round_robin_selector/#roundrobin-object","text":"Manifest path: $.models[*].attributes[*].value.selector.roundRobin The roundRobin object inside selector config indicates Dore that it needs to use the Random Selector to generate values for the attribute.","title":"roundRobin (object)"},{"location":"attribute_value_generators/round_robin_selector/#items-array-required","text":"Manifest path: $.models[*].attributes[*].value.selector.roundRobin.items List of values to select from. An item can be a number, a string, or an arbitrarily complex JSON object.","title":"items (array) [required]"},{"location":"attribute_value_generators/selector/","text":"Selector Manifest path: $.models[*].attributes[*].value Dore allows you to define a list of values from which a value is selected for an attribute during record generation. Consider an example where you have an attribute representing the size of a T-shirt and you wanted the value of this attribute to be one of the following values: \"S\" , \"M\" , \"L\" picked at random for each record. You can use the Random Selector for this. If, for example, you wanted the T-shirt size value to be picked from the list in a round robin fashion for each record, you can use the Round Robin Selector Example Selector example 1 2 3 4 5 6 7 8 9 10 11 { \"selector\" : { \"random\" : { \"items\" : [ \"S\" , \"M\" , \"L\" ] } } } Fields selector (object) Manifest path: $.models[*].attributes[*].value.selector The selector object inside value config indicates Dore that it needs to use a Selector to generate values for the attribute. Dore supports the following selector types. Please visit the selector specific documentation to view details on how to use a particular selector. Random Selector Round Robin Selector","title":"Selector"},{"location":"attribute_value_generators/selector/#selector","text":"Manifest path: $.models[*].attributes[*].value Dore allows you to define a list of values from which a value is selected for an attribute during record generation. Consider an example where you have an attribute representing the size of a T-shirt and you wanted the value of this attribute to be one of the following values: \"S\" , \"M\" , \"L\" picked at random for each record. You can use the Random Selector for this. If, for example, you wanted the T-shirt size value to be picked from the list in a round robin fashion for each record, you can use the Round Robin Selector","title":"Selector"},{"location":"attribute_value_generators/selector/#example","text":"Selector example 1 2 3 4 5 6 7 8 9 10 11 { \"selector\" : { \"random\" : { \"items\" : [ \"S\" , \"M\" , \"L\" ] } } }","title":"Example"},{"location":"attribute_value_generators/selector/#fields","text":"","title":"Fields"},{"location":"attribute_value_generators/selector/#selector-object","text":"Manifest path: $.models[*].attributes[*].value.selector The selector object inside value config indicates Dore that it needs to use a Selector to generate values for the attribute. Dore supports the following selector types. Please visit the selector specific documentation to view details on how to use a particular selector. Random Selector Round Robin Selector","title":"selector (object)"},{"location":"cli/cli_reference/","text":"CLI Reference Name dore - config based fake data generator Synopsis $ dore --manifest MANIFEST_FILE [ OPTIONS ] Description Dore is a tool that generates fake data for you based on a config (known as the manifest ). It can generate data for schemas with complex dependencies such as hierarchical schemas, schemas with PK/FK relations, nested values, and so on. Dore leverages other fake data generation libraries (ex: Faker) and generates fake data for complex schemas with dependencies amongst them. While Faker allows you to do something like generate a random UUID4 string , with Dore, you could do something along the lines of Generate a random UUID4 string as PK for a table and use these values as a FK in another table . Options --manifest MANIFEST_FILE Absolute path to Dore Manifest file. [ --help ] Show help for dore command. [ --scale-factor SCALE_FACTOR ] Scale factor for records generation. Accepted values: 1 , 0.1 , 0.25 , 3 , etc (numeric values). Default value : 1 [ --seed SEED ] Seed value to use for generating fake data. Accepted values: 1512312 , 1234 , etc (integer values) [ --drop-conficting-models ] Drop any conflicting models (pre-existing models with identical names as those in the manifest) that Dore encounters while executes. Please use this option with care as Dore will delete existing models and re-create them when it encounters any pre-existing models in a datastore with names identical to those in the manifest.` [ --cache CACHE_TYPE ] Cache type. While generating data for schemas with dependencies amongst models, Dore caches records for dependent models in order to avoid repeated DB calls. Accepted values : local , redis local When cache type is local , Dore uses a local Python dictionary based cache. redis When cache type is redis , Dore uses a redis cluster for caching. Default value : local [ --redis-host REDIS_HOST ] Host of the redis cluster which Dore uses for caching. This is a required arg when --cache is redis . Accepted values : 127.0.0.1 , redis15.localnet.org , etc. [ --redis-port REDIS_PORT ] Port of the redis cluster which Dore uses for caching. This is a required arg when --cache is redis . Accepted values : 6379 , 1234 , etc. [ --profile ] Run Dore with profiling. The profile output is stored in a .prof file. [ --manifest_var=value ] Specify values for variables in the manifest. You can use variables in the manifest by using {{manifest_var}} in the manifest file and supply values to each of the variables while invoking dore using the above argument.","title":"CLI Reference"},{"location":"cli/cli_reference/#cli-reference","text":"","title":"CLI Reference"},{"location":"cli/cli_reference/#name","text":"dore - config based fake data generator","title":"Name"},{"location":"cli/cli_reference/#synopsis","text":"$ dore --manifest MANIFEST_FILE [ OPTIONS ]","title":"Synopsis"},{"location":"cli/cli_reference/#description","text":"Dore is a tool that generates fake data for you based on a config (known as the manifest ). It can generate data for schemas with complex dependencies such as hierarchical schemas, schemas with PK/FK relations, nested values, and so on. Dore leverages other fake data generation libraries (ex: Faker) and generates fake data for complex schemas with dependencies amongst them. While Faker allows you to do something like generate a random UUID4 string , with Dore, you could do something along the lines of Generate a random UUID4 string as PK for a table and use these values as a FK in another table .","title":"Description"},{"location":"cli/cli_reference/#options","text":"","title":"Options"},{"location":"cli/cli_reference/#-manifest-manifest_file","text":"Absolute path to Dore Manifest file.","title":"--manifest MANIFEST_FILE"},{"location":"cli/cli_reference/#-help","text":"Show help for dore command.","title":"[--help]"},{"location":"cli/cli_reference/#-scale-factor-scale_factor","text":"Scale factor for records generation. Accepted values: 1 , 0.1 , 0.25 , 3 , etc (numeric values). Default value : 1","title":"[--scale-factor SCALE_FACTOR]"},{"location":"cli/cli_reference/#-seed-seed","text":"Seed value to use for generating fake data. Accepted values: 1512312 , 1234 , etc (integer values)","title":"[--seed SEED]"},{"location":"cli/cli_reference/#-drop-conficting-models","text":"Drop any conflicting models (pre-existing models with identical names as those in the manifest) that Dore encounters while executes. Please use this option with care as Dore will delete existing models and re-create them when it encounters any pre-existing models in a datastore with names identical to those in the manifest.`","title":"[--drop-conficting-models]"},{"location":"cli/cli_reference/#-cache-cache_type","text":"Cache type. While generating data for schemas with dependencies amongst models, Dore caches records for dependent models in order to avoid repeated DB calls. Accepted values : local , redis local When cache type is local , Dore uses a local Python dictionary based cache. redis When cache type is redis , Dore uses a redis cluster for caching. Default value : local","title":"[--cache CACHE_TYPE]"},{"location":"cli/cli_reference/#-redis-host-redis_host","text":"Host of the redis cluster which Dore uses for caching. This is a required arg when --cache is redis . Accepted values : 127.0.0.1 , redis15.localnet.org , etc.","title":"[--redis-host REDIS_HOST]"},{"location":"cli/cli_reference/#-redis-port-redis_port","text":"Port of the redis cluster which Dore uses for caching. This is a required arg when --cache is redis . Accepted values : 6379 , 1234 , etc.","title":"[--redis-port REDIS_PORT]"},{"location":"cli/cli_reference/#-profile","text":"Run Dore with profiling. The profile output is stored in a .prof file.","title":"[--profile]"},{"location":"cli/cli_reference/#-manifest_varvalue","text":"Specify values for variables in the manifest. You can use variables in the manifest by using {{manifest_var}} in the manifest file and supply values to each of the variables while invoking dore using the above argument.","title":"[--manifest_var=value]"},{"location":"manifest/manifest/","text":"Dore Manifest Overview To generate data for any schema with Dore, we need to create a Dore Manifest , which is a JSON config that contains specification of the target data. Here's a little mind map that tries to visually represent the manifest schema. It might be helpful to refer to this mind map while reading over the following sections. Fig 1: Manifest mind map A manifest can have multiple datastores (think of them as databases) and models (think of them as tables) defined. Each model in turn has a set of attributes (think of them as columns) associated with it. These three entities form the crux of the manifest. The protocol of a datastore determines the type of system the datastore represents. For example, \"mysql\" , \"mongodb\" , etc. are all protocols. The value config on an attribute is used to configure how Dore should generate values for the attribute. The three entities - datastores, models, and attributes - might have a set of protocol specific properties defined which tells Dore how these entities are or should be represented/persisted in the underlying system. Fields id (string) [required] Manifest path: $.id Each manifest should specify an id string to identify the manifest. Although Dore doesn't use this ID, it has been kept as a required field as it helps in improving the readability of the manifest. datastores (object) [required] Manifest path: $.datastores You can think of a datastore as a database in MySQL . A single Dore manifest can have multiple datastores definitions. Please refer Datastores for further details. models (object) [required] Manifest path: $.models You can think of a model as table in MySQL. A single dore manifest can have multiple models definitions. Please refer Models for further details.","title":"Manifest"},{"location":"manifest/manifest/#dore-manifest","text":"","title":"Dore Manifest"},{"location":"manifest/manifest/#overview","text":"To generate data for any schema with Dore, we need to create a Dore Manifest , which is a JSON config that contains specification of the target data. Here's a little mind map that tries to visually represent the manifest schema. It might be helpful to refer to this mind map while reading over the following sections. Fig 1: Manifest mind map A manifest can have multiple datastores (think of them as databases) and models (think of them as tables) defined. Each model in turn has a set of attributes (think of them as columns) associated with it. These three entities form the crux of the manifest. The protocol of a datastore determines the type of system the datastore represents. For example, \"mysql\" , \"mongodb\" , etc. are all protocols. The value config on an attribute is used to configure how Dore should generate values for the attribute. The three entities - datastores, models, and attributes - might have a set of protocol specific properties defined which tells Dore how these entities are or should be represented/persisted in the underlying system.","title":"Overview"},{"location":"manifest/manifest/#fields","text":"","title":"Fields"},{"location":"manifest/manifest/#id-string-required","text":"Manifest path: $.id Each manifest should specify an id string to identify the manifest. Although Dore doesn't use this ID, it has been kept as a required field as it helps in improving the readability of the manifest.","title":"id (string) [required]"},{"location":"manifest/manifest/#datastores-object-required","text":"Manifest path: $.datastores You can think of a datastore as a database in MySQL . A single Dore manifest can have multiple datastores definitions. Please refer Datastores for further details.","title":"datastores (object) [required]"},{"location":"manifest/manifest/#models-object-required","text":"Manifest path: $.models You can think of a model as table in MySQL. A single dore manifest can have multiple models definitions. Please refer Models for further details.","title":"models (object) [required]"},{"location":"manifest/attributes/attribute_definition/","text":"Attribute Definition Manifest path: $.models[*].attributes[*] You can think of an attribute as a MySQL column , an Elasticsearch Field , etc. An attribute definition needs to specify details about how Dore should generate values for it and also certain protocol specific properties for the attribute. Example Attribute Definition example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"another_attribute\" : { \"properties\" : { \"columnName\" : \"another_attribute_column\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"2021-01-01\" , \"end_date\" : \"2022-01-01\" } } } } } Fields value (object) [required] Manifest path: $.models[*].attributes[*].value This config is used to specify how Dore should generate values for the attribute. There are various attribute value generators that you can use to do things such as generate date between a given range , or select a value at random from a predefined list of values , etc. Please refer the value generators below for details: Faker Selector Ref Composite properties (object) Manifest path: $.models[*].attributes[*].properties This config is used to specify protocol specific properties for the attribute. Protocol specific properties of an attribute are required only when there is a need to persist the model associated with it and its records in any datastore. That is, the model is linked to a datastore and persistence on the model is set to \"FULL\" or is not explicitly mentioned in the manifest (as the Dore assumes the default persistence as \"FULL\" if it is not specified). Since each protocol has different requirements for configuring an attribute, this config varies from one protocol to the other. Please refer the protocol specific sections below for details: MySQL Attribute properties Postgres Attribute properties MongoDB Attribute properties Elasticsearch Attribute properties","title":"Attribute Definition"},{"location":"manifest/attributes/attribute_definition/#attribute-definition","text":"Manifest path: $.models[*].attributes[*] You can think of an attribute as a MySQL column , an Elasticsearch Field , etc. An attribute definition needs to specify details about how Dore should generate values for it and also certain protocol specific properties for the attribute.","title":"Attribute Definition"},{"location":"manifest/attributes/attribute_definition/#example","text":"Attribute Definition example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"another_attribute\" : { \"properties\" : { \"columnName\" : \"another_attribute_column\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"2021-01-01\" , \"end_date\" : \"2022-01-01\" } } } } }","title":"Example"},{"location":"manifest/attributes/attribute_definition/#fields","text":"","title":"Fields"},{"location":"manifest/attributes/attribute_definition/#value-object-required","text":"Manifest path: $.models[*].attributes[*].value This config is used to specify how Dore should generate values for the attribute. There are various attribute value generators that you can use to do things such as generate date between a given range , or select a value at random from a predefined list of values , etc. Please refer the value generators below for details: Faker Selector Ref Composite","title":"value (object) [required]"},{"location":"manifest/attributes/attribute_definition/#properties-object","text":"Manifest path: $.models[*].attributes[*].properties This config is used to specify protocol specific properties for the attribute. Protocol specific properties of an attribute are required only when there is a need to persist the model associated with it and its records in any datastore. That is, the model is linked to a datastore and persistence on the model is set to \"FULL\" or is not explicitly mentioned in the manifest (as the Dore assumes the default persistence as \"FULL\" if it is not specified). Since each protocol has different requirements for configuring an attribute, this config varies from one protocol to the other. Please refer the protocol specific sections below for details: MySQL Attribute properties Postgres Attribute properties MongoDB Attribute properties Elasticsearch Attribute properties","title":"properties (object)"},{"location":"manifest/attributes/attribute_reference/","text":"Attribute Reference Manifest path: $.models[*].attributes[*] An attribute can be defined in a file separate from the manifest (or the model) file. Use the ref field in the attribute definition and provde absolute path to the file that contains the Attribute Definition . Example Attribute Reference example 1 2 3 4 5 { \"an_attribute\" : { \"ref\" : \"/abs/path/to/file.json\" } } The definition for an_attribute is present in a separate file and the ref erence to that file is added in the manifest. Fields ref (string) [required] Manifest Path: $.models[*].attributes[*].ref Absolute path to file that contains the Attribute Definition .","title":"Attribute Reference"},{"location":"manifest/attributes/attribute_reference/#attribute-reference","text":"Manifest path: $.models[*].attributes[*] An attribute can be defined in a file separate from the manifest (or the model) file. Use the ref field in the attribute definition and provde absolute path to the file that contains the Attribute Definition .","title":"Attribute Reference"},{"location":"manifest/attributes/attribute_reference/#example","text":"Attribute Reference example 1 2 3 4 5 { \"an_attribute\" : { \"ref\" : \"/abs/path/to/file.json\" } } The definition for an_attribute is present in a separate file and the ref erence to that file is added in the manifest.","title":"Example"},{"location":"manifest/attributes/attribute_reference/#fields","text":"","title":"Fields"},{"location":"manifest/attributes/attribute_reference/#ref-string-required","text":"Manifest Path: $.models[*].attributes[*].ref Absolute path to file that contains the Attribute Definition .","title":"ref (string) [required]"},{"location":"manifest/attributes/attributes/","text":"Attributes You can think of an attribute as a MySQL Column , an Elasticsearch Field , etc. In a manifest, each model can have multiple attributes defined within it and each attribute is defined as an object with key as the attribute ID and value as the attribute definition. Example Attributes example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"attributes\" : { \"an_attribute\" : { // (1) \"ref\" : \"/abs/path/to/definition.js\" }, \"another_attribute\" : { // (2) \"properties\" : { \"columnName\" : \"another_attribute_column\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"2021-01-01\" , \"end_date\" : \"2022-01-01\" } } } } } } Definition of an Attribute with ID an_attribute . View Attribute Reference for details. Definition of an Attribute with ID another_attribute . View Attribute Definition for details. Fields attributes (object) [required] Manifest path: $.models[*].attributes This object is a container for all attribute definitions for a model. Each attribute is defined within the attributes object of a model and the keys act as their IDs. Accepted values for keys / Attribute IDs are represented by the following regex: ^[A-Za-z]+[A-Za-z0-9_\\-] i.e, it should start with an alphabetical character and can be followed by any number of alpha-numeric characters, hyphens, or underscores. In-line vs referenced definition An attribute can either be defined in-line in the manifest or in a separate file. Although we recommend spreading model and datastore definitions across different files, whether to move an attribute definition to a different file can be quite subjective. We recommend you take the call based on what seems more readable for you. Attribute Definition (when defining the attribute in-line) Attribute Reference (when defining the attribute in a separate file)","title":"Attributes"},{"location":"manifest/attributes/attributes/#attributes","text":"You can think of an attribute as a MySQL Column , an Elasticsearch Field , etc. In a manifest, each model can have multiple attributes defined within it and each attribute is defined as an object with key as the attribute ID and value as the attribute definition.","title":"Attributes"},{"location":"manifest/attributes/attributes/#example","text":"Attributes example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"attributes\" : { \"an_attribute\" : { // (1) \"ref\" : \"/abs/path/to/definition.js\" }, \"another_attribute\" : { // (2) \"properties\" : { \"columnName\" : \"another_attribute_column\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"2021-01-01\" , \"end_date\" : \"2022-01-01\" } } } } } } Definition of an Attribute with ID an_attribute . View Attribute Reference for details. Definition of an Attribute with ID another_attribute . View Attribute Definition for details.","title":"Example"},{"location":"manifest/attributes/attributes/#fields","text":"","title":"Fields"},{"location":"manifest/attributes/attributes/#attributes-object-required","text":"Manifest path: $.models[*].attributes This object is a container for all attribute definitions for a model. Each attribute is defined within the attributes object of a model and the keys act as their IDs. Accepted values for keys / Attribute IDs are represented by the following regex: ^[A-Za-z]+[A-Za-z0-9_\\-] i.e, it should start with an alphabetical character and can be followed by any number of alpha-numeric characters, hyphens, or underscores.","title":"attributes (object) [required]"},{"location":"manifest/attributes/attributes/#in-line-vs-referenced-definition","text":"An attribute can either be defined in-line in the manifest or in a separate file. Although we recommend spreading model and datastore definitions across different files, whether to move an attribute definition to a different file can be quite subjective. We recommend you take the call based on what seems more readable for you. Attribute Definition (when defining the attribute in-line) Attribute Reference (when defining the attribute in a separate file)","title":"In-line vs referenced definition"},{"location":"manifest/datastores/datastore_definition/","text":"Datastore Definition Manifest path: $.datastores[*] You can think of a datastore as a MySQL database , an Elasticsearch Cluster , etc. A datastore definition needs to specify which protocol the datastore uses (for ex: \"mysql\" ) and certain protocol specific properties of the datastore which Dore uses to interact with the underlying system. Example Datastore Definition example 1 2 3 4 5 6 7 8 9 10 { \"protocol\" : \"mysql\" , \"properties\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } } Fields protocol (string) [required] Manifest Path: $.datastores[*].protocol The protocol / type of system that the datastore represents. Allowed Values mysql mongodb postgres elasticsearch7 elasticsearch8 properties (object) [required] Manifest Path: $.datastores[*].properties This config defines protocol specific properties for the datastore. Each protocol has a different way of implementing the datastore abstraction. Please refer to the protocol specific sections below for details: MySQL Datastore properties Postgres Datastore properties MongoDB Datastore properties Elasticsearch Datastore properties","title":"Datastore Definition"},{"location":"manifest/datastores/datastore_definition/#datastore-definition","text":"Manifest path: $.datastores[*] You can think of a datastore as a MySQL database , an Elasticsearch Cluster , etc. A datastore definition needs to specify which protocol the datastore uses (for ex: \"mysql\" ) and certain protocol specific properties of the datastore which Dore uses to interact with the underlying system.","title":"Datastore Definition"},{"location":"manifest/datastores/datastore_definition/#example","text":"Datastore Definition example 1 2 3 4 5 6 7 8 9 10 { \"protocol\" : \"mysql\" , \"properties\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } }","title":"Example"},{"location":"manifest/datastores/datastore_definition/#fields","text":"","title":"Fields"},{"location":"manifest/datastores/datastore_definition/#protocol-string-required","text":"Manifest Path: $.datastores[*].protocol The protocol / type of system that the datastore represents.","title":"protocol (string) [required]"},{"location":"manifest/datastores/datastore_definition/#allowed-values","text":"mysql mongodb postgres elasticsearch7 elasticsearch8","title":"Allowed Values"},{"location":"manifest/datastores/datastore_definition/#properties-object-required","text":"Manifest Path: $.datastores[*].properties This config defines protocol specific properties for the datastore. Each protocol has a different way of implementing the datastore abstraction. Please refer to the protocol specific sections below for details: MySQL Datastore properties Postgres Datastore properties MongoDB Datastore properties Elasticsearch Datastore properties","title":"properties (object) [required]"},{"location":"manifest/datastores/datastore_reference/","text":"Datastore Reference Manifest path: $.datastores[*] A datastore can be defined in a file separate from the manifest file. Use the ref field in the datastore definition and provide absolute path to the file that actually contains the Datastore Definition . Example Datastore Reference example 1 2 3 4 5 { \"a_datastore\" : { \"ref\" : \"/abs/path/to/file.json\" } } The definition for a_datastore is present in a separate file located at /abs/path/to/file.json and a ref erence to that file is added in the manifest. Fields ref (string) [required] Manifest Path: $.datastores[*].ref Absolute path to file that contains the Datastore Definition .","title":"Datastore Reference"},{"location":"manifest/datastores/datastore_reference/#datastore-reference","text":"Manifest path: $.datastores[*] A datastore can be defined in a file separate from the manifest file. Use the ref field in the datastore definition and provide absolute path to the file that actually contains the Datastore Definition .","title":"Datastore Reference"},{"location":"manifest/datastores/datastore_reference/#example","text":"Datastore Reference example 1 2 3 4 5 { \"a_datastore\" : { \"ref\" : \"/abs/path/to/file.json\" } } The definition for a_datastore is present in a separate file located at /abs/path/to/file.json and a ref erence to that file is added in the manifest.","title":"Example"},{"location":"manifest/datastores/datastore_reference/#fields","text":"","title":"Fields"},{"location":"manifest/datastores/datastore_reference/#ref-string-required","text":"Manifest Path: $.datastores[*].ref Absolute path to file that contains the Datastore Definition .","title":"ref (string) [required]"},{"location":"manifest/datastores/datastores/","text":"Datastores You can think of a datastore as a MySQL database , an Elasticsearch cluster , etc. A manifest can have multiple datastores defined within it and each datastore is defined as an object with key as the datastore's ID and value as the datastore definition. Example Datastores example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"datastores\" : { \"a_datastore\" : { // (1) \"ref\" : \"/abs/path/to/definition.js\" }, \"another_datastore\" : { // (2) \"protocol\" : \"mysql\" , \"properties\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } } } } Definition of a datastore with ID a_datastore . View Datastore Reference for details. Definition of a datastore with ID another_datastore . View Datastore Definition for details. In this example, we define two datastores in the manifest -- a_datastore and another_datastore within the datastores field of the manifest. a_datastore and another_datastore act as IDs for the datastores and the values are their definitions. Fields datastores (object) [required] Manifest Path: $.datastores This object is a container for all datastore definitions. Each datastore is defined within the datastores object of the manifest and the keys act as their IDs. Accepted values for keys / datastore IDs are represented by the following regex: ^[A-Za-z]+[A-Za-z0-9_\\-] i.e, it should start with an alphabetical character and can be followed by any number of alpha-numeric characters, hyphens, or underscores. In-line vs referenced definition A datastore can either be defined in-line in the manifest or in a separate file and the file can then be referenced from the manifest. You would generally want to define each datastore in a separate file as it helps in keeping configs for each entity small and readable. Datastore Definition (when defining the model in-line) Datastore Reference (when defining the model in a separate file)","title":"Datastores"},{"location":"manifest/datastores/datastores/#datastores","text":"You can think of a datastore as a MySQL database , an Elasticsearch cluster , etc. A manifest can have multiple datastores defined within it and each datastore is defined as an object with key as the datastore's ID and value as the datastore definition.","title":"Datastores"},{"location":"manifest/datastores/datastores/#example","text":"Datastores example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"datastores\" : { \"a_datastore\" : { // (1) \"ref\" : \"/abs/path/to/definition.js\" }, \"another_datastore\" : { // (2) \"protocol\" : \"mysql\" , \"properties\" : { \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } } } } Definition of a datastore with ID a_datastore . View Datastore Reference for details. Definition of a datastore with ID another_datastore . View Datastore Definition for details. In this example, we define two datastores in the manifest -- a_datastore and another_datastore within the datastores field of the manifest. a_datastore and another_datastore act as IDs for the datastores and the values are their definitions.","title":"Example"},{"location":"manifest/datastores/datastores/#fields","text":"","title":"Fields"},{"location":"manifest/datastores/datastores/#datastores-object-required","text":"Manifest Path: $.datastores This object is a container for all datastore definitions. Each datastore is defined within the datastores object of the manifest and the keys act as their IDs. Accepted values for keys / datastore IDs are represented by the following regex: ^[A-Za-z]+[A-Za-z0-9_\\-] i.e, it should start with an alphabetical character and can be followed by any number of alpha-numeric characters, hyphens, or underscores.","title":"datastores (object) [required]"},{"location":"manifest/datastores/datastores/#in-line-vs-referenced-definition","text":"A datastore can either be defined in-line in the manifest or in a separate file and the file can then be referenced from the manifest. You would generally want to define each datastore in a separate file as it helps in keeping configs for each entity small and readable. Datastore Definition (when defining the model in-line) Datastore Reference (when defining the model in a separate file)","title":"In-line vs referenced definition"},{"location":"manifest/models/model_definition/","text":"Model Definition Manifest path: $.models[*] You can think of a model as a MySQL table , an Elasticsearch Index , etc. A model definition needs to specify details about attributes of the model, protocol specific properties for the model, and some additional information. Example Model Definition example 1 2 3 4 5 6 7 8 9 10 11 { \"records\" : 100 , \"persistence\" : \"FULL\" , \"datastore\" : \"a_datastore\" , \"properties\" : { \"tableName\" : \"anoter_model_tbl\" }, \"attributes\" : { // attribute definitions // } } Fields attributes (object) [required] Manifest path: $.models[*].attributes Each model will generally have a set of attributes associated with it. Please view Attributes for further details. persistence (string) Manifest path: $.models[*].persistence Dore allows you to specify various persistence levels for models. Please view Model Persistence for details. datastore (string) Manifest path: $.models[*].datastore Datastore ID of the datastore associated with the model. This is a required field in cases of models that have FULL persistence levels. records (integer) Manifest path: $.models[*].records Specify count of records to be generated for the model. Note: The actual count may vary The actual number of records that Dore generates for a model will depend on the value provided here as well as the --scale-factor value provided during invocation. For example, if a model has records as 10000 , and we provide a --scale-factor value of 0.1 when invoking Dore, the actual number of records generated by Dore will be 10000 * 0.1 = 1000 . properties (object) Manifest path: $.models[*].properties This config is used to specify protocol specific properties for the model. Protocol specific properties of a model are required only when there is a need to persist the model and its records in any datastore. That is, the model is linked to a datastore and persistence on the model is set to \"FULL\" or is not explicitly mentioned in the manifest (as the Dore assumes the default persistence as \"FULL\" if it is not specified). Since each protocol has different requirements for configuring a model, this config varies from one protocol to the other. Please refer the protocol specific sections below for details: MySQL Model properties Postgres Model properties MongoDB Model properties Elasticsearch Model properties","title":"Model Definition"},{"location":"manifest/models/model_definition/#model-definition","text":"Manifest path: $.models[*] You can think of a model as a MySQL table , an Elasticsearch Index , etc. A model definition needs to specify details about attributes of the model, protocol specific properties for the model, and some additional information.","title":"Model Definition"},{"location":"manifest/models/model_definition/#example","text":"Model Definition example 1 2 3 4 5 6 7 8 9 10 11 { \"records\" : 100 , \"persistence\" : \"FULL\" , \"datastore\" : \"a_datastore\" , \"properties\" : { \"tableName\" : \"anoter_model_tbl\" }, \"attributes\" : { // attribute definitions // } }","title":"Example"},{"location":"manifest/models/model_definition/#fields","text":"","title":"Fields"},{"location":"manifest/models/model_definition/#attributes-object-required","text":"Manifest path: $.models[*].attributes Each model will generally have a set of attributes associated with it. Please view Attributes for further details.","title":"attributes (object) [required]"},{"location":"manifest/models/model_definition/#persistence-string","text":"Manifest path: $.models[*].persistence Dore allows you to specify various persistence levels for models. Please view Model Persistence for details.","title":"persistence (string)"},{"location":"manifest/models/model_definition/#datastore-string","text":"Manifest path: $.models[*].datastore Datastore ID of the datastore associated with the model. This is a required field in cases of models that have FULL persistence levels.","title":"datastore (string)"},{"location":"manifest/models/model_definition/#records-integer","text":"Manifest path: $.models[*].records Specify count of records to be generated for the model. Note: The actual count may vary The actual number of records that Dore generates for a model will depend on the value provided here as well as the --scale-factor value provided during invocation. For example, if a model has records as 10000 , and we provide a --scale-factor value of 0.1 when invoking Dore, the actual number of records generated by Dore will be 10000 * 0.1 = 1000 .","title":"records (integer)"},{"location":"manifest/models/model_definition/#properties-object","text":"Manifest path: $.models[*].properties This config is used to specify protocol specific properties for the model. Protocol specific properties of a model are required only when there is a need to persist the model and its records in any datastore. That is, the model is linked to a datastore and persistence on the model is set to \"FULL\" or is not explicitly mentioned in the manifest (as the Dore assumes the default persistence as \"FULL\" if it is not specified). Since each protocol has different requirements for configuring a model, this config varies from one protocol to the other. Please refer the protocol specific sections below for details: MySQL Model properties Postgres Model properties MongoDB Model properties Elasticsearch Model properties","title":"properties (object)"},{"location":"manifest/models/model_persistence/","text":"Model Persistence Manifest path: $.models[*].persistence The persistence of a model determines how a particular model is persisted by Dore. Overview This is particularly useful when you have nested attributes that need to be represented as a separate model in itself but do not need to be persisted -- you would want to only generate records for that model to be reused elsewhere. Consider the case of a customer model which has a shippingAddress attribute. We would want to generate addresses for the customer and use them as values for the shippingAddress attribute. Since addresses are generally complex structures with multiple components, we would represent it as a separate model in the manifest so Dore can generate records for it. Fig: Schema with nested attribute But, we wouldn't want to persist the address model itself in the datastore. This would be the equivalent of having an address table with all addresses as rows in the table. We just want to use the model so that its records can be used for values in other attributes. Allowed values The Persistence levels supported by Dore along with its implications are given below: FULL When this persistence level is used on a model, Dore creates a model for this in the underlying datastore and persists records generated for this model in the datastore. MEMORY_ONLY When this persistence level is used on a model, Dore persists the records generated for the model in the cache only and does not create the model or persist records for the model in any datastore. NO_PERSIST When this persistence level is used on a model, Dore neither persists the model, nor the records generated for it in cache nor in any datastore. Each record is generated on the fly and discarded after being used.","title":"Model Persistence"},{"location":"manifest/models/model_persistence/#model-persistence","text":"Manifest path: $.models[*].persistence The persistence of a model determines how a particular model is persisted by Dore.","title":"Model Persistence"},{"location":"manifest/models/model_persistence/#overview","text":"This is particularly useful when you have nested attributes that need to be represented as a separate model in itself but do not need to be persisted -- you would want to only generate records for that model to be reused elsewhere. Consider the case of a customer model which has a shippingAddress attribute. We would want to generate addresses for the customer and use them as values for the shippingAddress attribute. Since addresses are generally complex structures with multiple components, we would represent it as a separate model in the manifest so Dore can generate records for it. Fig: Schema with nested attribute But, we wouldn't want to persist the address model itself in the datastore. This would be the equivalent of having an address table with all addresses as rows in the table. We just want to use the model so that its records can be used for values in other attributes.","title":"Overview"},{"location":"manifest/models/model_persistence/#allowed-values","text":"The Persistence levels supported by Dore along with its implications are given below: FULL When this persistence level is used on a model, Dore creates a model for this in the underlying datastore and persists records generated for this model in the datastore. MEMORY_ONLY When this persistence level is used on a model, Dore persists the records generated for the model in the cache only and does not create the model or persist records for the model in any datastore. NO_PERSIST When this persistence level is used on a model, Dore neither persists the model, nor the records generated for it in cache nor in any datastore. Each record is generated on the fly and discarded after being used.","title":"Allowed values"},{"location":"manifest/models/model_reference/","text":"Model Reference Manifest path: $.models[*] A model can be defined in a file separate from the manifest file. Use the ref field in the model definition and provide absolute path to the file that contains the Model Definition . Example Model Reference example 1 2 3 4 5 { \"a_model\" : { \"ref\" : \"/abs/path/to/file.json\" } } The definition for a_model is present in a separate file located at /abs/path/to/file.json and a ref erence to that file is added in the manifest. Fields ref (string) [required] Manifest Path: $.models[*].ref Absolute path to file that contains the Model Definition .","title":"Model Reference"},{"location":"manifest/models/model_reference/#model-reference","text":"Manifest path: $.models[*] A model can be defined in a file separate from the manifest file. Use the ref field in the model definition and provide absolute path to the file that contains the Model Definition .","title":"Model Reference"},{"location":"manifest/models/model_reference/#example","text":"Model Reference example 1 2 3 4 5 { \"a_model\" : { \"ref\" : \"/abs/path/to/file.json\" } } The definition for a_model is present in a separate file located at /abs/path/to/file.json and a ref erence to that file is added in the manifest.","title":"Example"},{"location":"manifest/models/model_reference/#fields","text":"","title":"Fields"},{"location":"manifest/models/model_reference/#ref-string-required","text":"Manifest Path: $.models[*].ref Absolute path to file that contains the Model Definition .","title":"ref (string) [required]"},{"location":"manifest/models/models/","text":"Models You can think of a model as a MySQL table , an Elasticsearch index , etc. A manifest can have multiple models defined within it and each model is defined as an object with key as the model ID and value as the model definition. Example Models example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"models\" : { \"a_model\" : { // (1) \"ref\" : \"/abs/path/to/definition.js\" }, \"another_model\" : { // (2) \"records\" : 100 , \"persistence\" : \"FULL\" , \"datastore\" : \"a_datastore\" , \"properties\" : { \"tableName\" : \"anoter_model_tbl\" }, \"attributes\" : { // (3) // attribute definitions // } } } } Definition of a Model with ID a_model . View Model Reference for details. Definition of a Model with ID another_model . View Model Definition for details. Attributes for another_model . View Attributes for further details. Fields models (object) [required] Manifest path: $.models This object is a container for all model definitions. Each model is defined within the models object of the manifest and the keys act as their IDs. Accepted values for keys / model IDs are represented by the following regex: ^[A-Za-z]+[A-Za-z0-9_\\-] i.e, it should start with an alphabetical character and can be followed by any number of alpha-numeric characters, hyphens, or underscores. In-line vs referenced definition A model can either be defined in-line in the manifest or in a separate file. You would generally want to define each model in a separate file as it helps in keeping configs for each entity small and readable. Model Definition (when defining the model in-line) Model Reference (when defining the model in a separate file)","title":"Models"},{"location":"manifest/models/models/#models","text":"You can think of a model as a MySQL table , an Elasticsearch index , etc. A manifest can have multiple models defined within it and each model is defined as an object with key as the model ID and value as the model definition.","title":"Models"},{"location":"manifest/models/models/#example","text":"Models example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"models\" : { \"a_model\" : { // (1) \"ref\" : \"/abs/path/to/definition.js\" }, \"another_model\" : { // (2) \"records\" : 100 , \"persistence\" : \"FULL\" , \"datastore\" : \"a_datastore\" , \"properties\" : { \"tableName\" : \"anoter_model_tbl\" }, \"attributes\" : { // (3) // attribute definitions // } } } } Definition of a Model with ID a_model . View Model Reference for details. Definition of a Model with ID another_model . View Model Definition for details. Attributes for another_model . View Attributes for further details.","title":"Example"},{"location":"manifest/models/models/#fields","text":"","title":"Fields"},{"location":"manifest/models/models/#models-object-required","text":"Manifest path: $.models This object is a container for all model definitions. Each model is defined within the models object of the manifest and the keys act as their IDs. Accepted values for keys / model IDs are represented by the following regex: ^[A-Za-z]+[A-Za-z0-9_\\-] i.e, it should start with an alphabetical character and can be followed by any number of alpha-numeric characters, hyphens, or underscores.","title":"models (object) [required]"},{"location":"manifest/models/models/#in-line-vs-referenced-definition","text":"A model can either be defined in-line in the manifest or in a separate file. You would generally want to define each model in a separate file as it helps in keeping configs for each entity small and readable. Model Definition (when defining the model in-line) Model Reference (when defining the model in a separate file)","title":"In-line vs referenced definition"},{"location":"protocols/elasticsearch/","text":"Dore Elasticsearch Protocol Protocol name: elasticsearch7 , elasticsearch8 Manifest fields Field in Manifest What it represents Datastore Cluster Model Index Attribute Field Datastore Properties Manifest path: $.datastores[*].properties Example Elasticsearch Datastore properties example 1 2 3 4 5 6 { \"host\" : \"127.0.0.1\" , \"port\" : \"9001\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" } Fields host (string) [required] Manifest path: $.datastores[*].properties.host Elasticsearch host. port (string) [required] Manifest path: $.datastores[*].properties.port Elasticsearch port. user (string) [required] Manifest path: $.datastores[*].properties.user Elasticsearch username for connecting to the database. password (string) [required] Manifest path: $.datastores[*].properties.password Elasticsearch password for connecting to the database. Model Properties Manifest path: $.models[*].properties Example Elasticsearch Model properties example 1 2 3 { \"indexName\" : \"foobar\" } Fields indexName (string) [required] Manifest path: $.models[*].properties.indexName Name of the Elasticsearch index that the model corresponds to. While interacting with the Elasticsearch indexes corresponding to the model, Dore uses this schemaName to refer to the schema in the Elasticsearch database. Attribute Properties Manifest path: $.models[*].attributes[*].properties Example Elasticsearch Attribute properties example 1 2 3 4 { \"fieldName\" : \"foo\" , \"fieldType\" : \"keyword\" } Fields fieldName (string) [required] Manifest path: $.models[*].attributes[*].properties.fieldName Name of the Elasticsearch field that the attribute corresponds to. fieldType (string) [required] Manifest path: $.models[*].attributes[*].properties.fieldType Name of the Elasticsearch field that the attribute corresponds to. All field data types supported by Elasticsearch are supported here.","title":"Elasticsearch"},{"location":"protocols/elasticsearch/#dore-elasticsearch-protocol","text":"Protocol name: elasticsearch7 , elasticsearch8","title":"Dore Elasticsearch Protocol"},{"location":"protocols/elasticsearch/#manifest-fields","text":"Field in Manifest What it represents Datastore Cluster Model Index Attribute Field","title":"Manifest fields"},{"location":"protocols/elasticsearch/#datastore-properties","text":"Manifest path: $.datastores[*].properties","title":"Datastore Properties"},{"location":"protocols/elasticsearch/#example","text":"Elasticsearch Datastore properties example 1 2 3 4 5 6 { \"host\" : \"127.0.0.1\" , \"port\" : \"9001\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" }","title":"Example"},{"location":"protocols/elasticsearch/#fields","text":"","title":"Fields"},{"location":"protocols/elasticsearch/#host-string-required","text":"Manifest path: $.datastores[*].properties.host Elasticsearch host.","title":"host (string) [required]"},{"location":"protocols/elasticsearch/#port-string-required","text":"Manifest path: $.datastores[*].properties.port Elasticsearch port.","title":"port (string) [required]"},{"location":"protocols/elasticsearch/#user-string-required","text":"Manifest path: $.datastores[*].properties.user Elasticsearch username for connecting to the database.","title":"user (string) [required]"},{"location":"protocols/elasticsearch/#password-string-required","text":"Manifest path: $.datastores[*].properties.password Elasticsearch password for connecting to the database.","title":"password (string) [required]"},{"location":"protocols/elasticsearch/#model-properties","text":"Manifest path: $.models[*].properties","title":"Model Properties"},{"location":"protocols/elasticsearch/#example_1","text":"Elasticsearch Model properties example 1 2 3 { \"indexName\" : \"foobar\" }","title":"Example"},{"location":"protocols/elasticsearch/#fields_1","text":"","title":"Fields"},{"location":"protocols/elasticsearch/#indexname-string-required","text":"Manifest path: $.models[*].properties.indexName Name of the Elasticsearch index that the model corresponds to. While interacting with the Elasticsearch indexes corresponding to the model, Dore uses this schemaName to refer to the schema in the Elasticsearch database.","title":"indexName (string) [required]"},{"location":"protocols/elasticsearch/#attribute-properties","text":"Manifest path: $.models[*].attributes[*].properties","title":"Attribute Properties"},{"location":"protocols/elasticsearch/#example_2","text":"Elasticsearch Attribute properties example 1 2 3 4 { \"fieldName\" : \"foo\" , \"fieldType\" : \"keyword\" }","title":"Example"},{"location":"protocols/elasticsearch/#fields_2","text":"","title":"Fields"},{"location":"protocols/elasticsearch/#fieldname-string-required","text":"Manifest path: $.models[*].attributes[*].properties.fieldName Name of the Elasticsearch field that the attribute corresponds to.","title":"fieldName (string) [required]"},{"location":"protocols/elasticsearch/#fieldtype-string-required","text":"Manifest path: $.models[*].attributes[*].properties.fieldType Name of the Elasticsearch field that the attribute corresponds to. All field data types supported by Elasticsearch are supported here.","title":"fieldType (string) [required]"},{"location":"protocols/mongodb/","text":"Dore MongoDB Protocol Protocol name: mongodb Manifest fields Field in Manifest What it represents Datastore Database Model Collection Attribute Field Datastore Properties Manifest path: $.datastores[*].properties Example MongoDB Datastore properties example 1 2 3 4 5 6 7 { \"host\" : \"127.0.0.1\" , \"port\" : \"27101\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } Fields host (string) [required] Manifest path: $.datastores[*].properties.host MongoDB host. port (string) [required] Manifest path: $.datastores[*].properties.port MongoDB port. user (string) [required] Manifest path: $.datastores[*].properties.user MongoDB username for connecting to the database. password (string) [required] Manifest path: $.datastores[*].properties.password MongoDB password for connecting to the database. database (string) [required] Manifest path: $.datastores[*].properties.database Name of the MongoDB database to connect to. Model Properties Manifest path: $.models[*].properties Example MongoDB Model properties example 1 2 3 { \"collectionName\" : \"foobar\" } Fields collectionName (string) [required] Manifest path: $.models[*].properties.collectionName Name of the MongoDB collection that the model corresponds to. While interacting with the MongoDB collection corresponding to the model, Dore uses this collectionName to refer to the model in the MongoDB database. Attribute Properties Manifest path: $.models[*].attributes[*].properties Example MongoDB Attribute properties example 1 2 3 { \"fieldName\" : \"foo\" } Fields fieldName (string) [required] Manifest path: $.models[*].attributes[*].properties.fieldName Name of the MongoDB field that the attribute corresponds to.","title":"MongoDB"},{"location":"protocols/mongodb/#dore-mongodb-protocol","text":"Protocol name: mongodb","title":"Dore MongoDB Protocol"},{"location":"protocols/mongodb/#manifest-fields","text":"Field in Manifest What it represents Datastore Database Model Collection Attribute Field","title":"Manifest fields"},{"location":"protocols/mongodb/#datastore-properties","text":"Manifest path: $.datastores[*].properties","title":"Datastore Properties"},{"location":"protocols/mongodb/#example","text":"MongoDB Datastore properties example 1 2 3 4 5 6 7 { \"host\" : \"127.0.0.1\" , \"port\" : \"27101\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" }","title":"Example"},{"location":"protocols/mongodb/#fields","text":"","title":"Fields"},{"location":"protocols/mongodb/#host-string-required","text":"Manifest path: $.datastores[*].properties.host MongoDB host.","title":"host (string) [required]"},{"location":"protocols/mongodb/#port-string-required","text":"Manifest path: $.datastores[*].properties.port MongoDB port.","title":"port (string) [required]"},{"location":"protocols/mongodb/#user-string-required","text":"Manifest path: $.datastores[*].properties.user MongoDB username for connecting to the database.","title":"user (string) [required]"},{"location":"protocols/mongodb/#password-string-required","text":"Manifest path: $.datastores[*].properties.password MongoDB password for connecting to the database.","title":"password (string) [required]"},{"location":"protocols/mongodb/#database-string-required","text":"Manifest path: $.datastores[*].properties.database Name of the MongoDB database to connect to.","title":"database (string) [required]"},{"location":"protocols/mongodb/#model-properties","text":"Manifest path: $.models[*].properties","title":"Model Properties"},{"location":"protocols/mongodb/#example_1","text":"MongoDB Model properties example 1 2 3 { \"collectionName\" : \"foobar\" }","title":"Example"},{"location":"protocols/mongodb/#fields_1","text":"","title":"Fields"},{"location":"protocols/mongodb/#collectionname-string-required","text":"Manifest path: $.models[*].properties.collectionName Name of the MongoDB collection that the model corresponds to. While interacting with the MongoDB collection corresponding to the model, Dore uses this collectionName to refer to the model in the MongoDB database.","title":"collectionName (string) [required]"},{"location":"protocols/mongodb/#attribute-properties","text":"Manifest path: $.models[*].attributes[*].properties","title":"Attribute Properties"},{"location":"protocols/mongodb/#example_2","text":"MongoDB Attribute properties example 1 2 3 { \"fieldName\" : \"foo\" }","title":"Example"},{"location":"protocols/mongodb/#fields_2","text":"","title":"Fields"},{"location":"protocols/mongodb/#fieldname-string-required","text":"Manifest path: $.models[*].attributes[*].properties.fieldName Name of the MongoDB field that the attribute corresponds to.","title":"fieldName (string) [required]"},{"location":"protocols/mysql/","text":"Dore MySQL Protocol Protocol name: mysql Manifest fields Field in Manifest What it represents Datastore Database Model Table Attribute Column Datastore Properties Manifest path: $.datastores[*].properties Example MySQL Datastore properties example 1 2 3 4 5 6 7 { \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } Fields host (string) [required] Manifest path: $.datastores[*].properties.host MySQL host. port (string) [required] Manifest path: $.datastores[*].properties.port MySQL port. user (string) [required] Manifest path: $.datastores[*].properties.user MySQL username for connecting to the database. password (string) [required] Manifest path: $.datastores[*].properties.password MySQL password for connecting to the database. database (string) [required] Manifest path: $.datastores[*].properties.database Name of the MySQL database to connect to. Model Properties Manifest path: $.models[*].properties Example MySQL Model properties example 1 2 3 { \"tableName\" : \"foobar\" } Fields tableName (string) [required] Manifest path: $.models[*].properties.tableName Name of the MySQL table that the model corresponds to. While interacting with the MySQL table corresponding to the model, Dore uses this tableName to refer to the model in the MySQL database. Attribute Properties Manifest path: $.models[*].attributes[*].properties Example MySQL Attribute properties example 1 2 3 4 { \"columnName\" : \"foo\" , \"columnType\" : \"VARCHAR(30)\" } Fields columnName (string) [required] Manifest path: $.models[*].attributes[*].properties.columnName Name of the MySQL column that the attribute corresponds to. While creating tables in MySQL for MySQL bound models in the manifest, Dore infers the required column name from this field's value. columnType (string) [required] Manifest path: $.models[*].attributes[*].properties.columnType Data type of the MySQL column that the attribute corresponds to. All data types supported by MySQL are supported here.","title":"MySQL"},{"location":"protocols/mysql/#dore-mysql-protocol","text":"Protocol name: mysql","title":"Dore MySQL Protocol"},{"location":"protocols/mysql/#manifest-fields","text":"Field in Manifest What it represents Datastore Database Model Table Attribute Column","title":"Manifest fields"},{"location":"protocols/mysql/#datastore-properties","text":"Manifest path: $.datastores[*].properties","title":"Datastore Properties"},{"location":"protocols/mysql/#example","text":"MySQL Datastore properties example 1 2 3 4 5 6 7 { \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" }","title":"Example"},{"location":"protocols/mysql/#fields","text":"","title":"Fields"},{"location":"protocols/mysql/#host-string-required","text":"Manifest path: $.datastores[*].properties.host MySQL host.","title":"host (string) [required]"},{"location":"protocols/mysql/#port-string-required","text":"Manifest path: $.datastores[*].properties.port MySQL port.","title":"port (string) [required]"},{"location":"protocols/mysql/#user-string-required","text":"Manifest path: $.datastores[*].properties.user MySQL username for connecting to the database.","title":"user (string) [required]"},{"location":"protocols/mysql/#password-string-required","text":"Manifest path: $.datastores[*].properties.password MySQL password for connecting to the database.","title":"password (string) [required]"},{"location":"protocols/mysql/#database-string-required","text":"Manifest path: $.datastores[*].properties.database Name of the MySQL database to connect to.","title":"database (string) [required]"},{"location":"protocols/mysql/#model-properties","text":"Manifest path: $.models[*].properties","title":"Model Properties"},{"location":"protocols/mysql/#example_1","text":"MySQL Model properties example 1 2 3 { \"tableName\" : \"foobar\" }","title":"Example"},{"location":"protocols/mysql/#fields_1","text":"","title":"Fields"},{"location":"protocols/mysql/#tablename-string-required","text":"Manifest path: $.models[*].properties.tableName Name of the MySQL table that the model corresponds to. While interacting with the MySQL table corresponding to the model, Dore uses this tableName to refer to the model in the MySQL database.","title":"tableName (string) [required]"},{"location":"protocols/mysql/#attribute-properties","text":"Manifest path: $.models[*].attributes[*].properties","title":"Attribute Properties"},{"location":"protocols/mysql/#example_2","text":"MySQL Attribute properties example 1 2 3 4 { \"columnName\" : \"foo\" , \"columnType\" : \"VARCHAR(30)\" }","title":"Example"},{"location":"protocols/mysql/#fields_2","text":"","title":"Fields"},{"location":"protocols/mysql/#columnname-string-required","text":"Manifest path: $.models[*].attributes[*].properties.columnName Name of the MySQL column that the attribute corresponds to. While creating tables in MySQL for MySQL bound models in the manifest, Dore infers the required column name from this field's value.","title":"columnName (string) [required]"},{"location":"protocols/mysql/#columntype-string-required","text":"Manifest path: $.models[*].attributes[*].properties.columnType Data type of the MySQL column that the attribute corresponds to. All data types supported by MySQL are supported here.","title":"columnType (string) [required]"},{"location":"protocols/postgresql/","text":"Dore PostgreSQL Protocol Protocol name: postgres Manifest fields Field in Manifest What it represents Datastore Database Model Table Attribute Column Datastore Properties Manifest path: $.datastores[*].properties Example Postgres Datastore properties example 1 2 3 4 5 6 7 { \"host\" : \"127.0.0.1\" , \"port\" : \"5432\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" } Fields host (string) [required] Manifest path: $.datastores[*].properties.host PostgreSQL host. port (string) [required] Manifest path: $.datastores[*].properties.port PostgreSQL port. user (string) [required] Manifest path: $.datastores[*].properties.user PostgreSQL username for connecting to the database. password (string) [required] Manifest path: $.datastores[*].properties.password PostgreSQL password for connecting to the database. database (string) [required] Manifest path: $.datastores[*].properties.database Name of the PostgreSQL database to connect to. Model Properties Manifest path: $.models[*].properties Example Postgres Model properties example 1 2 3 4 { \"tableName\" : \"foobar\" , \"schemaName\" : \" baz\" } Fields tableName (string) [required] Manifest path: $.models[*].properties.tableName Name of the PostgreSQL table that the model corresponds to. While interacting with the PostgreSQL table corresponding to the model, Dore uses this tableName to refer to the model in the PostgreSQL database. schemaName (string) [required] Manifest path: $.models[*].properties.schemaName Name of the PostgreSQL schema that the model corresponds to. While interacting with the PostgreSQL table corresponding to the model, Dore uses this schemaName to refer to the schema in the PostgreSQL database. Attribute Properties Manifest path: $.models[*].attributes[*].properties Example Postgres Attribute properties example 1 2 3 4 { \"columnName\" : \"foo\" , \"columnType\" : \"VARCHAR(30)\" } Fields columnName (string) [required] Manifest path: $.models[*].attributes[*].properties.columnName Name of the Postgres column that the attribute corresponds to. While creating tables in Postgres for Postgres bound models in the manifest, Dore infers the required column name from this field's value. columnType (string) [required] Manifest path: $.models[*].attributes[*].properties.columnType Data type of the Postgres column that the attribute corresponds to. All data types supported by Postgres are supported here.","title":"PostgreSQL"},{"location":"protocols/postgresql/#dore-postgresql-protocol","text":"Protocol name: postgres","title":"Dore PostgreSQL Protocol"},{"location":"protocols/postgresql/#manifest-fields","text":"Field in Manifest What it represents Datastore Database Model Table Attribute Column","title":"Manifest fields"},{"location":"protocols/postgresql/#datastore-properties","text":"Manifest path: $.datastores[*].properties","title":"Datastore Properties"},{"location":"protocols/postgresql/#example","text":"Postgres Datastore properties example 1 2 3 4 5 6 7 { \"host\" : \"127.0.0.1\" , \"port\" : \"5432\" , \"user\" : \"john_doe\" , \"password\" : \"yourpassword\" , \"database\" : \"foobar\" }","title":"Example"},{"location":"protocols/postgresql/#fields","text":"","title":"Fields"},{"location":"protocols/postgresql/#host-string-required","text":"Manifest path: $.datastores[*].properties.host PostgreSQL host.","title":"host (string) [required]"},{"location":"protocols/postgresql/#port-string-required","text":"Manifest path: $.datastores[*].properties.port PostgreSQL port.","title":"port (string) [required]"},{"location":"protocols/postgresql/#user-string-required","text":"Manifest path: $.datastores[*].properties.user PostgreSQL username for connecting to the database.","title":"user (string) [required]"},{"location":"protocols/postgresql/#password-string-required","text":"Manifest path: $.datastores[*].properties.password PostgreSQL password for connecting to the database.","title":"password (string) [required]"},{"location":"protocols/postgresql/#database-string-required","text":"Manifest path: $.datastores[*].properties.database Name of the PostgreSQL database to connect to.","title":"database (string) [required]"},{"location":"protocols/postgresql/#model-properties","text":"Manifest path: $.models[*].properties","title":"Model Properties"},{"location":"protocols/postgresql/#example_1","text":"Postgres Model properties example 1 2 3 4 { \"tableName\" : \"foobar\" , \"schemaName\" : \" baz\" }","title":"Example"},{"location":"protocols/postgresql/#fields_1","text":"","title":"Fields"},{"location":"protocols/postgresql/#tablename-string-required","text":"Manifest path: $.models[*].properties.tableName Name of the PostgreSQL table that the model corresponds to. While interacting with the PostgreSQL table corresponding to the model, Dore uses this tableName to refer to the model in the PostgreSQL database.","title":"tableName (string) [required]"},{"location":"protocols/postgresql/#schemaname-string-required","text":"Manifest path: $.models[*].properties.schemaName Name of the PostgreSQL schema that the model corresponds to. While interacting with the PostgreSQL table corresponding to the model, Dore uses this schemaName to refer to the schema in the PostgreSQL database.","title":"schemaName (string) [required]"},{"location":"protocols/postgresql/#attribute-properties","text":"Manifest path: $.models[*].attributes[*].properties","title":"Attribute Properties"},{"location":"protocols/postgresql/#example_2","text":"Postgres Attribute properties example 1 2 3 4 { \"columnName\" : \"foo\" , \"columnType\" : \"VARCHAR(30)\" }","title":"Example"},{"location":"protocols/postgresql/#fields_2","text":"","title":"Fields"},{"location":"protocols/postgresql/#columnname-string-required","text":"Manifest path: $.models[*].attributes[*].properties.columnName Name of the Postgres column that the attribute corresponds to. While creating tables in Postgres for Postgres bound models in the manifest, Dore infers the required column name from this field's value.","title":"columnName (string) [required]"},{"location":"protocols/postgresql/#columntype-string-required","text":"Manifest path: $.models[*].attributes[*].properties.columnType Data type of the Postgres column that the attribute corresponds to. All data types supported by Postgres are supported here.","title":"columnType (string) [required]"},{"location":"tutorial/attribute_value_definition/","text":"Overview Dore generates fake data for models of schemas by generating fake data for each of its attributes and combining them to form records. In order for Dore to generate value for an attribute, we need to configure details in the attribute using the value object which defines how Dore generates value for it. The Value Definition of an attribute should specify an Attribute Value Generator , along with any parameters that it might need, that Dore will use to generate values for the attribute. Let's define value configs for each of the attributes we created in the previous section. Customer Model This section contains details of value definitions for attributes of the customer model. customerId Since each customer ID needs to be a unique string, we can use UUID values for the customer_id column. Dore supports various Attribute Value Generators that you can use to define how value for a particular attribute should to be generated. In order to generate UUID values, we can use the Faker Value Generator . Let's provide the value definition for customerId attribute to indicate that Dore should generate UUID values for this column using the Faker Value Generator: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : {} } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : {}, \"customerId\" : {}, \"orderDate\" : {} } } } } customerName For generating random names, we can use the Faker Value Generator again and use the name method. Let's add the value definition for customerName attribute to our manifest: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : {}, \"customerId\" : {}, \"orderDate\" : {} } } } } Order Model This section contains details of value definitions for attributes of the order model. orderId The Order ID , similar to a Customer ID , uniquely defines an Oder. We can use UUID values for the order_id column. dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : {}, \"orderDate\" : {} } } } } customerId Based on the ecommerce schema , The customer_id column of the Order table is a Foreign Key which references the customer_id column of the Customer table. You can use the Ref Value Generator to define that Dore should generate values for an attribute by deriving its values of from values of another attribute. Such attributes are also known as Dependent Attributes . Since the value of order.customerId attribute is dependent on customer.customerId attribute, we can add value definition for order.customerId as follows: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : {} } } } } orderDate For generating random dates, we can use the Faker Value Generator again and use the date_between method: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : { \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } } } We have defined the value config for orderDate attribute to be a random date in the last year \u27a1 Next : Protocol specific properties","title":"Attribute Value Definition"},{"location":"tutorial/attribute_value_definition/#overview","text":"Dore generates fake data for models of schemas by generating fake data for each of its attributes and combining them to form records. In order for Dore to generate value for an attribute, we need to configure details in the attribute using the value object which defines how Dore generates value for it. The Value Definition of an attribute should specify an Attribute Value Generator , along with any parameters that it might need, that Dore will use to generate values for the attribute. Let's define value configs for each of the attributes we created in the previous section.","title":"Overview"},{"location":"tutorial/attribute_value_definition/#customer-model","text":"This section contains details of value definitions for attributes of the customer model.","title":"Customer Model"},{"location":"tutorial/attribute_value_definition/#customerid","text":"Since each customer ID needs to be a unique string, we can use UUID values for the customer_id column. Dore supports various Attribute Value Generators that you can use to define how value for a particular attribute should to be generated. In order to generate UUID values, we can use the Faker Value Generator . Let's provide the value definition for customerId attribute to indicate that Dore should generate UUID values for this column using the Faker Value Generator: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : {} } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : {}, \"customerId\" : {}, \"orderDate\" : {} } } } }","title":"customerId"},{"location":"tutorial/attribute_value_definition/#customername","text":"For generating random names, we can use the Faker Value Generator again and use the name method. Let's add the value definition for customerName attribute to our manifest: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : {}, \"customerId\" : {}, \"orderDate\" : {} } } } }","title":"customerName"},{"location":"tutorial/attribute_value_definition/#order-model","text":"This section contains details of value definitions for attributes of the order model.","title":"Order Model"},{"location":"tutorial/attribute_value_definition/#orderid","text":"The Order ID , similar to a Customer ID , uniquely defines an Oder. We can use UUID values for the order_id column. dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : {}, \"orderDate\" : {} } } } }","title":"orderId"},{"location":"tutorial/attribute_value_definition/#customerid_1","text":"Based on the ecommerce schema , The customer_id column of the Order table is a Foreign Key which references the customer_id column of the Customer table. You can use the Ref Value Generator to define that Dore should generate values for an attribute by deriving its values of from values of another attribute. Such attributes are also known as Dependent Attributes . Since the value of order.customerId attribute is dependent on customer.customerId attribute, we can add value definition for order.customerId as follows: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : {} } } } }","title":"customerId"},{"location":"tutorial/attribute_value_definition/#orderdate","text":"For generating random dates, we can use the Faker Value Generator again and use the date_between method: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : { \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : { \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } } } We have defined the value config for orderDate attribute to be a random date in the last year \u27a1 Next : Protocol specific properties","title":"orderDate"},{"location":"tutorial/conclusion/","text":"Conclusion Over the course of this tutorial, we have learnt quite a few things: The E-Commerce schema How to use Dore to generate fake data for the ecommerce schema. The Dore Manifest . What are Datastores , Models , and Attributes and how to define them in a Manifest for any schema. How to add Value Definitions for attributes in the Manifest which define how Dore will generate values for them. How to invoke Dore with a Manifest. How to use variables in the Manifest and provide values for the variables while invoking Dore. How to handle model conflicts . How to split the manifest into multiple files to keep the datastore and model definitions readable and maintainable. Although this tutorial was specific to creating a single MySQL database with a few tables, Dore can work with many kinds of systems and schemas. So, what are you waiting for? Start creating manifests for schemas for your own services and share it with fellow members! On and ending note, thank you for going through this tutorial. We hope it has helped in making working with Dore a bit easier. Documentation We recommend checking out our documentation to get detailed information about the various manifest fields as well as usage of the Dore command in order to use Dore for your own use cases. CLI Reference : to view details on usage of dore command. Manifest Reference : to view documentation on Dore Manifest.","title":"Conclusion"},{"location":"tutorial/conclusion/#conclusion","text":"Over the course of this tutorial, we have learnt quite a few things: The E-Commerce schema How to use Dore to generate fake data for the ecommerce schema. The Dore Manifest . What are Datastores , Models , and Attributes and how to define them in a Manifest for any schema. How to add Value Definitions for attributes in the Manifest which define how Dore will generate values for them. How to invoke Dore with a Manifest. How to use variables in the Manifest and provide values for the variables while invoking Dore. How to handle model conflicts . How to split the manifest into multiple files to keep the datastore and model definitions readable and maintainable. Although this tutorial was specific to creating a single MySQL database with a few tables, Dore can work with many kinds of systems and schemas. So, what are you waiting for? Start creating manifests for schemas for your own services and share it with fellow members! On and ending note, thank you for going through this tutorial. We hope it has helped in making working with Dore a bit easier.","title":"Conclusion"},{"location":"tutorial/conclusion/#documentation","text":"We recommend checking out our documentation to get detailed information about the various manifest fields as well as usage of the Dore command in order to use Dore for your own use cases. CLI Reference : to view details on usage of dore command. Manifest Reference : to view documentation on Dore Manifest.","title":"Documentation"},{"location":"tutorial/create_manifest/","text":"Creating the Manifest Let's go ahead and create a new file called dore-ecommerce-manifest.json and open it up in our favorite editor. Manifest id Each manifest needs to have an ID. So let's add that to the Manifest: dore-ecommerce-manifest.json 1 2 3 { \"id\" : \"ecommerce-example\" } Each manifest should specify an id string to identify the manifest. Although Dore doesn't use this ID, it has been kept as a required field as it helps in improving the readability of the manifest. \u27a1 Next: Defining the E-Commerce Datastore","title":"Creating the Manifest"},{"location":"tutorial/create_manifest/#creating-the-manifest","text":"Let's go ahead and create a new file called dore-ecommerce-manifest.json and open it up in our favorite editor.","title":"Creating the Manifest"},{"location":"tutorial/create_manifest/#manifest-id","text":"Each manifest needs to have an ID. So let's add that to the Manifest: dore-ecommerce-manifest.json 1 2 3 { \"id\" : \"ecommerce-example\" } Each manifest should specify an id string to identify the manifest. Although Dore doesn't use this ID, it has been kept as a required field as it helps in improving the readability of the manifest. \u27a1 Next: Defining the E-Commerce Datastore","title":"Manifest id"},{"location":"tutorial/dore_manifest/","text":"Dore Manifest To generate data for any schema with Dore, we need to create the Dore Manifest for the schema, which is a definition of the target data requirements. Dore uses the manifest to create the required databases, tables, and columns, and fill the tables up with fake data as per the requirements. Here's a short summary of what we'll be defining in the Manifest: What we're configuring Field JSON Path in Manifest Details of target databases Datastores $.datastores Details of target tables Models $.models Details of columns of target tables Attributes $.models[*].attributes Details on attributes which define how Dore will generate value for them Value Configs $.models[*].attrributes[*].value The fields mentioned above form the core of the Dore Manifest. We will be creating a manifest for the ecommerce schema from scratch and learn how to define each of the above fields in the manifest. \u27a1 Next: Creating the Manifest","title":"Dore Manifest"},{"location":"tutorial/dore_manifest/#dore-manifest","text":"To generate data for any schema with Dore, we need to create the Dore Manifest for the schema, which is a definition of the target data requirements. Dore uses the manifest to create the required databases, tables, and columns, and fill the tables up with fake data as per the requirements. Here's a short summary of what we'll be defining in the Manifest: What we're configuring Field JSON Path in Manifest Details of target databases Datastores $.datastores Details of target tables Models $.models Details of columns of target tables Attributes $.models[*].attributes Details on attributes which define how Dore will generate value for them Value Configs $.models[*].attrributes[*].value The fields mentioned above form the core of the Dore Manifest. We will be creating a manifest for the ecommerce schema from scratch and learn how to define each of the above fields in the manifest. \u27a1 Next: Creating the Manifest","title":"Dore Manifest"},{"location":"tutorial/ecommerce_datastore/","text":"Defining the E-Commerce Datastore Since all tables of the ecommerce schema are present in an Dore_Ecommerce database, we need a way to define details of the MySQL database in the Manifest. Datastores In Dore, Datastores represent data sources. It usually represents a particular database, whether that's a database running within a locally installed MySQL server, a remote Elasticsearch cluster, or a hosted MongoDB database. Let's add the datastores object in the manifest: dore-ecommerce-manifest.json 1 2 3 4 { \"id\" : \"ecommerce-example\" , \"datastores\" : {} } This will contain definition for the Dore_Ecommerce MySQL database. Defining the ecommerce Datastore Datastores are configured at $.datastores in the Manifest, i.e, inside the datastores object we added above. Each datastore is defined with a key which will be the ID for the Datastore and value as the Datastore Definition . Let's add the ecommerce datastore to our Manifest: dore-ecommerce-manifest.json 1 2 3 4 5 6 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : {} } } In the snippet above, we have defined a datastore with ID ecommerce . We will add the definition for Dore_Ecommerce database within this object. Protocol Each datastore must specify a protocol which indicates the type of system the datastore represents. In our case, the datastore represents a mysql database. Let's specify that ecommerce datastore uses mysql protocol: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" } } } Properties We also need to define certain protocol specific properties for a datastore which allows Dore to interact with the underlying system: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } } } These properties specify details which Dore uses to identify, connect, and interact with the Dore_Ecommerce MySQL database represented by the Datastore. Please provide details for your MySQL instance for the host , port , user , and password fields above. \u27a1 Next: Models and Attributes","title":"Datastore"},{"location":"tutorial/ecommerce_datastore/#defining-the-e-commerce-datastore","text":"Since all tables of the ecommerce schema are present in an Dore_Ecommerce database, we need a way to define details of the MySQL database in the Manifest.","title":"Defining the E-Commerce Datastore"},{"location":"tutorial/ecommerce_datastore/#datastores","text":"In Dore, Datastores represent data sources. It usually represents a particular database, whether that's a database running within a locally installed MySQL server, a remote Elasticsearch cluster, or a hosted MongoDB database. Let's add the datastores object in the manifest: dore-ecommerce-manifest.json 1 2 3 4 { \"id\" : \"ecommerce-example\" , \"datastores\" : {} } This will contain definition for the Dore_Ecommerce MySQL database.","title":"Datastores"},{"location":"tutorial/ecommerce_datastore/#defining-the-ecommerce-datastore","text":"Datastores are configured at $.datastores in the Manifest, i.e, inside the datastores object we added above. Each datastore is defined with a key which will be the ID for the Datastore and value as the Datastore Definition . Let's add the ecommerce datastore to our Manifest: dore-ecommerce-manifest.json 1 2 3 4 5 6 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : {} } } In the snippet above, we have defined a datastore with ID ecommerce . We will add the definition for Dore_Ecommerce database within this object.","title":"Defining the ecommerce Datastore"},{"location":"tutorial/ecommerce_datastore/#protocol","text":"Each datastore must specify a protocol which indicates the type of system the datastore represents. In our case, the datastore represents a mysql database. Let's specify that ecommerce datastore uses mysql protocol: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" } } }","title":"Protocol"},{"location":"tutorial/ecommerce_datastore/#properties","text":"We also need to define certain protocol specific properties for a datastore which allows Dore to interact with the underlying system: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } } } These properties specify details which Dore uses to identify, connect, and interact with the Dore_Ecommerce MySQL database represented by the Datastore. Please provide details for your MySQL instance for the host , port , user , and password fields above. \u27a1 Next: Models and Attributes","title":"Properties"},{"location":"tutorial/ecommerce_manifest_review/","text":"Ecommerce Manifest Review Let's do a quick review of what we have done so far: We started off by learning about the Ecommerce schema, its tables, and the relationships amongst them. [ref: The Ecommerce schema \u2197] Then, we learnt that in order to generate data for any schema with Dore we need to create a Manifest for the schema which defines requirements of the target data. [ref: Dore Manifest \u2197] We then proceeded with creating the Manifest and providing the Manifest with an ID. [ref: Creating the Manifest \u2197] Next, we learnt about Datastores and we defined the ecommerce Datastore, which defines details for the Dore_Ecommerce MySQL database in the Manifest. [ref: Datastore \u2197] Then, we learnt about Models and Attributes . We defined the customer and order Models and their Attributes. [ref: Models and Attributes \u2197] We then learnt about Attribute Value Definitions and defined how Dore should generate values for each of the attributes of the customer and order models. [ref: Models and Attributes \u2197] Finally, we learn about Protocol specific properties for Models and Attributes and defined protocol specific properties for each of the models and their attributes in our Manifest. [ref: Model and Attribute Properties \u2197] The following snippet contains the complete ecommerce manifest: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"properties\" : { \"tableName\" : \"Customer\" }, \"attributes\" : { \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"properties\" : { \"columnName\" : \"customer_name\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"properties\" : { \"tableName\" : \"Order\" }, \"attributes\" : { \"orderId\" : { \"properties\" : { \"columnName\" : \"order_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : { \"properties\" : { \"columnName\" : \"order_date\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } } } Next, we're going to try invoking Dore with the above manifest and verify that we're able to generate data as per the schema requirements. \u27a1 Next: Invoke Dore","title":"Manifest Review"},{"location":"tutorial/ecommerce_manifest_review/#ecommerce-manifest-review","text":"Let's do a quick review of what we have done so far: We started off by learning about the Ecommerce schema, its tables, and the relationships amongst them. [ref: The Ecommerce schema \u2197] Then, we learnt that in order to generate data for any schema with Dore we need to create a Manifest for the schema which defines requirements of the target data. [ref: Dore Manifest \u2197] We then proceeded with creating the Manifest and providing the Manifest with an ID. [ref: Creating the Manifest \u2197] Next, we learnt about Datastores and we defined the ecommerce Datastore, which defines details for the Dore_Ecommerce MySQL database in the Manifest. [ref: Datastore \u2197] Then, we learnt about Models and Attributes . We defined the customer and order Models and their Attributes. [ref: Models and Attributes \u2197] We then learnt about Attribute Value Definitions and defined how Dore should generate values for each of the attributes of the customer and order models. [ref: Models and Attributes \u2197] Finally, we learn about Protocol specific properties for Models and Attributes and defined protocol specific properties for each of the models and their attributes in our Manifest. [ref: Model and Attribute Properties \u2197] The following snippet contains the complete ecommerce manifest: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"properties\" : { \"tableName\" : \"Customer\" }, \"attributes\" : { \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"properties\" : { \"columnName\" : \"customer_name\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"properties\" : { \"tableName\" : \"Order\" }, \"attributes\" : { \"orderId\" : { \"properties\" : { \"columnName\" : \"order_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : { \"properties\" : { \"columnName\" : \"order_date\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } } } Next, we're going to try invoking Dore with the above manifest and verify that we're able to generate data as per the schema requirements. \u27a1 Next: Invoke Dore","title":"Ecommerce Manifest Review"},{"location":"tutorial/ecommerce_schema/","text":"The E-Commerce Schema Let's say we want to generate fake data in a MySQL database named Dore_Ecommerce for the following schema: Ecommerce schema The schema contains two tables: Customer Contains details of customers of the ecommerce. Each customer is uniquely identified by a customer_id and has a name which is stored in the customer_name column. Order Contains details of orders placed with the ecommerce. Each order is uniquely identified by an order_id and is placed on a certain date which is stored in the order_date column. Since orders are placed by customers, each order is associated with a customer_id which identifies one of the customers in the Customer table. Note that the schema mentions a Foreign Key relationship between Order.customer_id and Customer.customer_id . Generating fake data for schemas with dependencies between columns in a database agnostic way is one of the core problems that Dore was designed to solve. \u27a1 Next: Dore Manifest","title":"The E-Commerce schema"},{"location":"tutorial/ecommerce_schema/#the-e-commerce-schema","text":"Let's say we want to generate fake data in a MySQL database named Dore_Ecommerce for the following schema: Ecommerce schema The schema contains two tables: Customer Contains details of customers of the ecommerce. Each customer is uniquely identified by a customer_id and has a name which is stored in the customer_name column. Order Contains details of orders placed with the ecommerce. Each order is uniquely identified by an order_id and is placed on a certain date which is stored in the order_date column. Since orders are placed by customers, each order is associated with a customer_id which identifies one of the customers in the Customer table. Note that the schema mentions a Foreign Key relationship between Order.customer_id and Customer.customer_id . Generating fake data for schemas with dependencies between columns in a database agnostic way is one of the core problems that Dore was designed to solve. \u27a1 Next: Dore Manifest","title":"The E-Commerce Schema"},{"location":"tutorial/handling_model_conflicts/","text":"Handling Model Conflicts In the previous section, we invoked Dore a second time over the course of this tutorial and encountered the following logs: [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :50:44,375 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :50:44,384 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] Traceback ( most recent call last ) : File \"/../venv/bin/dore\" , line 8 , in <module> sys.exit ( main ()) File \"/../venv/lib/python3.9/site-packages/dore/__main__.py\" , line 50 , in main engine () File \"/../venv/lib/python3.9/site-packages/dore/engine/engine.py\" , line 90 , in engine config, context = bootstrap () File \"/../venv/lib/python3.9/site-packages/dore/engine/bootstrap.py\" , line 39 , in bootstrap initialize_models ( config, context ) File \"/../venv/lib/python3.9/site-packages/dore/engine/initialize_models.py\" , line 46 , in initialize_models raise ModelConflictException ( model.config () .id () , datastore.id ()) dore.exceptions.model_conflict_exception.ModelConflictException: conflicting model [ customer ] found in datastore [ ecommerce ] Since the should table already exist after our first run from the Invoke Dore section of the tutorial, Dore raises a ModelConflictException when it tries to create the customer table in the ecommerce database again. !! Caution !! You can make Dore ignore this by providing the --drop-conflicting-models option while invoking Dore. Please note that using this flag allows Dore to drop/delete the conflicting models in the database and create a fresh one. Since this will result in to deletion of data in your databases, please be extremely careful while using this . You can invoke Dore by providing this flag as follows: Invoke dore with option to ignore conflicting models dore --manifest /abs/path/to/ecommerce-dore-manifest.json \\ --mysql-user = root \\ --mysql-password = password \\ --drop-conflicting-models You should now be able to see a successful run. We've highlighted parts of the logs that indicate deletion of existing tables below: [ 2022 -10-11 00 :48:22,612 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :48:22,613 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :48:22,656 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :48:22,665 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :48:22,671 ] [ INFO ] [ dore.protocol.mysql.mysql_delete_model ] : dropping table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :48:22,710 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :48:22,751 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :48:22,758 ] [ INFO ] [ dore.protocol.mysql.mysql_delete_model ] : dropping table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :48:22,786 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :48:22,845 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ customer ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 10 /10 [ 00 :00< 00 :00, 5106 .91it/s ] [ 2022 -10-11 00 :48:22,885 ] [ INFO ] [ dore.engine.engine ] : [ 10 ] records generated for model [ customer ] [ 2022 -10-11 00 :48:22,886 ] [ INFO ] [ dore.engine.engine ] : populating cache with records for [ customer ] [ 2022 -10-11 00 :48:22,902 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ order ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 100 /100 [ 00 :00< 00 :00, 15007 .53it/s ] [ 2022 -10-11 00 :48:22,939 ] [ INFO ] [ dore.engine.engine ] : [ 100 ] records generated for model [ order ] [ 2022 -10-11 00 :48:22,939 ] [ INFO ] [ dore.engine.engine ] : Clearing cache We can see that Dore deleted the conflicting models from the datastore after checking for their existence and recreated them in the lines highlighted above. \u27a1 Next: Multi-File Manifest","title":"Handling Model Conflicts"},{"location":"tutorial/handling_model_conflicts/#handling-model-conflicts","text":"In the previous section, we invoked Dore a second time over the course of this tutorial and encountered the following logs: [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :50:44,375 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :50:44,384 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] Traceback ( most recent call last ) : File \"/../venv/bin/dore\" , line 8 , in <module> sys.exit ( main ()) File \"/../venv/lib/python3.9/site-packages/dore/__main__.py\" , line 50 , in main engine () File \"/../venv/lib/python3.9/site-packages/dore/engine/engine.py\" , line 90 , in engine config, context = bootstrap () File \"/../venv/lib/python3.9/site-packages/dore/engine/bootstrap.py\" , line 39 , in bootstrap initialize_models ( config, context ) File \"/../venv/lib/python3.9/site-packages/dore/engine/initialize_models.py\" , line 46 , in initialize_models raise ModelConflictException ( model.config () .id () , datastore.id ()) dore.exceptions.model_conflict_exception.ModelConflictException: conflicting model [ customer ] found in datastore [ ecommerce ] Since the should table already exist after our first run from the Invoke Dore section of the tutorial, Dore raises a ModelConflictException when it tries to create the customer table in the ecommerce database again. !! Caution !! You can make Dore ignore this by providing the --drop-conflicting-models option while invoking Dore. Please note that using this flag allows Dore to drop/delete the conflicting models in the database and create a fresh one. Since this will result in to deletion of data in your databases, please be extremely careful while using this . You can invoke Dore by providing this flag as follows: Invoke dore with option to ignore conflicting models dore --manifest /abs/path/to/ecommerce-dore-manifest.json \\ --mysql-user = root \\ --mysql-password = password \\ --drop-conflicting-models You should now be able to see a successful run. We've highlighted parts of the logs that indicate deletion of existing tables below: [ 2022 -10-11 00 :48:22,612 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :48:22,613 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :48:22,656 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :48:22,665 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :48:22,671 ] [ INFO ] [ dore.protocol.mysql.mysql_delete_model ] : dropping table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :48:22,710 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :48:22,751 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :48:22,758 ] [ INFO ] [ dore.protocol.mysql.mysql_delete_model ] : dropping table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :48:22,786 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :48:22,845 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ customer ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 10 /10 [ 00 :00< 00 :00, 5106 .91it/s ] [ 2022 -10-11 00 :48:22,885 ] [ INFO ] [ dore.engine.engine ] : [ 10 ] records generated for model [ customer ] [ 2022 -10-11 00 :48:22,886 ] [ INFO ] [ dore.engine.engine ] : populating cache with records for [ customer ] [ 2022 -10-11 00 :48:22,902 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ order ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 100 /100 [ 00 :00< 00 :00, 15007 .53it/s ] [ 2022 -10-11 00 :48:22,939 ] [ INFO ] [ dore.engine.engine ] : [ 100 ] records generated for model [ order ] [ 2022 -10-11 00 :48:22,939 ] [ INFO ] [ dore.engine.engine ] : Clearing cache We can see that Dore deleted the conflicting models from the datastore after checking for their existence and recreated them in the lines highlighted above. \u27a1 Next: Multi-File Manifest","title":"Handling Model Conflicts"},{"location":"tutorial/invoke_dore/","text":"Invoke Dore Let's invoke Dore with the Ecommerce Manifest file: dore --manifest /abs/path/to/ecommerce-dore-manifest.json If you were able to view logs that look like the one shown below, then take a moment to congratulate yourself for a successful Dore invocation! [ 2022 -10-11 00 :47:38,548 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :47:38,548 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :47:38,586 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :47:38,593 ] [ INFO ] [ dore.protocol.mysql.mysql_create_datastore ] : creating database [ Dore_Ecommerce ] [ 2022 -10-11 00 :47:38,614 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :47:38,623 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :47:38,663 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :47:38,671 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :47:38,730 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ customer ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 10 /10 [ 00 :00< 00 :00, 2936 .98it/s ] [ 2022 -10-11 00 :47:38,768 ] [ INFO ] [ dore.engine.engine ] : [ 10 ] records generated for model [ customer ] [ 2022 -10-11 00 :47:38,768 ] [ INFO ] [ dore.engine.engine ] : populating cache with records for [ customer ] [ 2022 -10-11 00 :47:38,784 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ order ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 100 /100 [ 00 :00< 00 :00, 13760 .39it/s ] [ 2022 -10-11 00 :47:38,822 ] [ INFO ] [ dore.engine.engine ] : [ 100 ] records generated for model [ order ] [ 2022 -10-11 00 :47:38,822 ] [ INFO ] [ dore.engine.engine ] : Clearing cache Dore creates the required databases, tables, and generates data in the tables based on schema specified in the manifest. We recommend you check out data created by Dore in your MySQL instance by running a few queries. \u27a1 Next: Manifest Variables","title":"Invoke Dore"},{"location":"tutorial/invoke_dore/#invoke-dore","text":"Let's invoke Dore with the Ecommerce Manifest file: dore --manifest /abs/path/to/ecommerce-dore-manifest.json If you were able to view logs that look like the one shown below, then take a moment to congratulate yourself for a successful Dore invocation! [ 2022 -10-11 00 :47:38,548 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :47:38,548 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :47:38,586 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :47:38,593 ] [ INFO ] [ dore.protocol.mysql.mysql_create_datastore ] : creating database [ Dore_Ecommerce ] [ 2022 -10-11 00 :47:38,614 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :47:38,623 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Customer ` ] [ 2022 -10-11 00 :47:38,663 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :47:38,671 ] [ INFO ] [ dore.protocol.mysql.mysql_create_model ] : creating table [ ` Dore_Ecommerce ` . ` Order ` ] [ 2022 -10-11 00 :47:38,730 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ customer ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 10 /10 [ 00 :00< 00 :00, 2936 .98it/s ] [ 2022 -10-11 00 :47:38,768 ] [ INFO ] [ dore.engine.engine ] : [ 10 ] records generated for model [ customer ] [ 2022 -10-11 00 :47:38,768 ] [ INFO ] [ dore.engine.engine ] : populating cache with records for [ customer ] [ 2022 -10-11 00 :47:38,784 ] [ INFO ] [ dore.engine.engine ] : generating records for model [ order ] 100 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 100 /100 [ 00 :00< 00 :00, 13760 .39it/s ] [ 2022 -10-11 00 :47:38,822 ] [ INFO ] [ dore.engine.engine ] : [ 100 ] records generated for model [ order ] [ 2022 -10-11 00 :47:38,822 ] [ INFO ] [ dore.engine.engine ] : Clearing cache Dore creates the required databases, tables, and generates data in the tables based on schema specified in the manifest. We recommend you check out data created by Dore in your MySQL instance by running a few queries. \u27a1 Next: Manifest Variables","title":"Invoke Dore"},{"location":"tutorial/manifest_variables/","text":"Manifest Variables Let's look at the definition for ecommerce Datastore in our Manifest. We see that we have added database credentials: user and password , in plain text in the manifest file. ecommerce Datastore in dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } } } Ideally, we would not want to store database credentials in the Manifest this way as it leads to security concerns. A better approach could perhaps be to use a variables as a placeholder in the manifest for the user and password fields and provide those values while invoking Dore. Dore supports specifying variables in the manifest using the pystache library (which supports the mustache syntax) and providing values to those variables while invoking Dore. The mustache syntax for specifying variables is {{variable_name}} . Let's change the datastore definition to use variables for user and password instead of the actual values as mentioned in the previous snippet. Using variables in Manifest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"{{mysql-user}}\" , \"password\" : \"{{mysql-password}}\" } } } } You can provide values for variables while invoking Dore as follows: dore --manifest MANIFEST_FILE [ OPTIONS ] \\ --varname1 = value \\ --varname2 = value Let's try invoking Dore once again by providing values for the mysql-user and mysql-password variables above and ensure everything works fine: Invoke dore with values for manifest variables dore --manifest /abs/path/to/ecommerce-dore-manifest.json \\ --mysql-user = root \\ --mysql-password = password If you\u2019re using the same database as you previously used and nothing changed in MySQL, you should see the following in Dore logs: [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :50:44,375 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :50:44,384 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] Traceback ( most recent call last ) : File \"/../venv/bin/dore\" , line 8 , in <module> sys.exit ( main ()) File \"/../venv/lib/python3.9/site-packages/dore/__main__.py\" , line 50 , in main engine () File \"/../venv/lib/python3.9/site-packages/dore/engine/engine.py\" , line 90 , in engine config, context = bootstrap () File \"/../venv/lib/python3.9/site-packages/dore/engine/bootstrap.py\" , line 39 , in bootstrap initialize_models ( config, context ) File \"/../venv/lib/python3.9/site-packages/dore/engine/initialize_models.py\" , line 46 , in initialize_models raise ModelConflictException ( model.config () .id () , datastore.id ()) dore.exceptions.model_conflict_exception.ModelConflictException: conflicting model [ customer ] found in datastore [ ecommerce ] Head over to the next section to learn what the exception means and how to fix it. \u27a1 Next: Handling Model Conflicts","title":"Manifest Variables"},{"location":"tutorial/manifest_variables/#manifest-variables","text":"Let's look at the definition for ecommerce Datastore in our Manifest. We see that we have added database credentials: user and password , in plain text in the manifest file. ecommerce Datastore in dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } } } Ideally, we would not want to store database credentials in the Manifest this way as it leads to security concerns. A better approach could perhaps be to use a variables as a placeholder in the manifest for the user and password fields and provide those values while invoking Dore. Dore supports specifying variables in the manifest using the pystache library (which supports the mustache syntax) and providing values to those variables while invoking Dore. The mustache syntax for specifying variables is {{variable_name}} . Let's change the datastore definition to use variables for user and password instead of the actual values as mentioned in the previous snippet. Using variables in Manifest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"{{mysql-user}}\" , \"password\" : \"{{mysql-password}}\" } } } } You can provide values for variables while invoking Dore as follows: dore --manifest MANIFEST_FILE [ OPTIONS ] \\ --varname1 = value \\ --varname2 = value Let's try invoking Dore once again by providing values for the mysql-user and mysql-password variables above and ensure everything works fine: Invoke dore with values for manifest variables dore --manifest /abs/path/to/ecommerce-dore-manifest.json \\ --mysql-user = root \\ --mysql-password = password If you\u2019re using the same database as you previously used and nothing changed in MySQL, you should see the following in Dore logs: [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.manifest.manifest_factory ] : successfully loaded manifest [ ecommerce-example ] located at [ /../dore-ecommerce-manifest.json ] [ 2022 -10-11 00 :50:44,326 ] [ INFO ] [ dore.datastore.datastore_factory ] : initializing datastore [ ecommerce ] [ 2022 -10-11 00 :50:44,375 ] [ INFO ] [ dore.protocol.mysql.mysql_datastore_exists ] : checking if database [ Dore_Ecommerce ] exists [ 2022 -10-11 00 :50:44,384 ] [ INFO ] [ dore.protocol.mysql.mysql_model_exists ] : checking existence for table [ ` Dore_Ecommerce ` . ` Customer ` ] Traceback ( most recent call last ) : File \"/../venv/bin/dore\" , line 8 , in <module> sys.exit ( main ()) File \"/../venv/lib/python3.9/site-packages/dore/__main__.py\" , line 50 , in main engine () File \"/../venv/lib/python3.9/site-packages/dore/engine/engine.py\" , line 90 , in engine config, context = bootstrap () File \"/../venv/lib/python3.9/site-packages/dore/engine/bootstrap.py\" , line 39 , in bootstrap initialize_models ( config, context ) File \"/../venv/lib/python3.9/site-packages/dore/engine/initialize_models.py\" , line 46 , in initialize_models raise ModelConflictException ( model.config () .id () , datastore.id ()) dore.exceptions.model_conflict_exception.ModelConflictException: conflicting model [ customer ] found in datastore [ ecommerce ] Head over to the next section to learn what the exception means and how to fix it. \u27a1 Next: Handling Model Conflicts","title":"Manifest Variables"},{"location":"tutorial/model_and_attribute_properties/","text":"Protocol specific properties for Models and Attributes Similar to how Datastores need to have protocol specific properties defined in the manifest so Dore can connect and interact with the underlying system, Models and Attributes need to have protocol specific properties , such as table names for models, column names and their data types for attributes, defined in the manifest so Dore can interact with the entities in the underlying system. Let's add these properties to the Models and Attributes we created in the previous section as shown below: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"properties\" : { \"tableName\" : \"Customer\" }, \"attributes\" : { \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"properties\" : { \"columnName\" : \"customer_name\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"properties\" : { \"tableName\" : \"Order\" }, \"attributes\" : { \"orderId\" : { \"properties\" : { \"columnName\" : \"order_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : { \"properties\" : { \"columnName\" : \"order_date\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } } } With these additions, we have completed the ecommerce manifest. \u27a1 Next: Manifest Review","title":"Model and Attribute Properties"},{"location":"tutorial/model_and_attribute_properties/#protocol-specific-properties-for-models-and-attributes","text":"Similar to how Datastores need to have protocol specific properties defined in the manifest so Dore can connect and interact with the underlying system, Models and Attributes need to have protocol specific properties , such as table names for models, column names and their data types for attributes, defined in the manifest so Dore can interact with the entities in the underlying system. Let's add these properties to the Models and Attributes we created in the previous section as shown below: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"properties\" : { \"tableName\" : \"Customer\" }, \"attributes\" : { \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerName\" : { \"properties\" : { \"columnName\" : \"customer_name\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"name\" : {} } } } } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"properties\" : { \"tableName\" : \"Order\" }, \"attributes\" : { \"orderId\" : { \"properties\" : { \"columnName\" : \"order_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"faker\" : { \"uuid4\" : {} } } }, \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" }, \"value\" : { \"ref\" : \"customer.customerId\" } }, \"orderDate\" : { \"properties\" : { \"columnName\" : \"order_date\" , \"columnType\" : \"DATE\" }, \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } } } With these additions, we have completed the ecommerce manifest. \u27a1 Next: Manifest Review","title":"Protocol specific properties for Models and Attributes"},{"location":"tutorial/models_and_attributes/","text":"Models and Attributes Now that we have configured details for the Dore_Ecommerce database, we need to provide definitions for the Customer and Order tables of the e-commerce schema . In Dore, A Model represents a set of structured data. Models usually correspond to tables/collections/indexes in a database/cluster. Attributes correspond to columns/fields. Let's add the models object in the manifest which will contain the model definitions: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : {} } We will be adding definitions for each of the tables of the ecommerce schema . Models Like datastores, each model is defined with a key which will be the ID for the Model and value as the Model Definition . Let's add two models, customer and order , corresponding to Customer and Order tables of the ecommerce schema : dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : {}, \"order\" : {} } } Linked Datastore Since Customer and Order tables need to be created within the Dore_Ecommerce database, we define that both customer and order models are associated with the ecommerce datastore: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" }, \"order\" : { \"datastore\" : \"ecommerce\" } } } Records We need to define the count of records that Dore should generate for each of the models. So let's define this for the customer and order models as follows: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 } } } With the records field on the models, we have defined that Dore should generate 10 records for the customer model and 100 records for the order model. Attributes The Customer table of the e-commerce schema has two columns: customer_id customer_name And the Order table has three columns: order_id customer_id order_date In order to add definitions for these columns in the manifest, we need to define Attributes for the customer and order models corresponding to these columns. Attributes for a model are defined at $.models[*].attributes in the Manifest; i.e, within the attributes field for a model. Like datastores and models, each attribute is defined with a key which will be the ID for the Attribute and value as the Attribute Definition . dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : {}, \"customerName\" : {} } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : {}, \"customerId\" : {}, \"orderDate\" : {} } } } } We will be now be adding value definitions for the attributes above. \u27a1 Next: Attribute Value Definition","title":"Models and Attributes"},{"location":"tutorial/models_and_attributes/#models-and-attributes","text":"Now that we have configured details for the Dore_Ecommerce database, we need to provide definitions for the Customer and Order tables of the e-commerce schema . In Dore, A Model represents a set of structured data. Models usually correspond to tables/collections/indexes in a database/cluster. Attributes correspond to columns/fields. Let's add the models object in the manifest which will contain the model definitions: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : {} } We will be adding definitions for each of the tables of the ecommerce schema .","title":"Models and Attributes"},{"location":"tutorial/models_and_attributes/#models","text":"Like datastores, each model is defined with a key which will be the ID for the Model and value as the Model Definition . Let's add two models, customer and order , corresponding to Customer and Order tables of the ecommerce schema : dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : {}, \"order\" : {} } }","title":"Models"},{"location":"tutorial/models_and_attributes/#linked-datastore","text":"Since Customer and Order tables need to be created within the Dore_Ecommerce database, we define that both customer and order models are associated with the ecommerce datastore: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" }, \"order\" : { \"datastore\" : \"ecommerce\" } } }","title":"Linked Datastore"},{"location":"tutorial/models_and_attributes/#records","text":"We need to define the count of records that Dore should generate for each of the models. So let's define this for the customer and order models as follows: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 } } } With the records field on the models, we have defined that Dore should generate 10 records for the customer model and 100 records for the order model.","title":"Records"},{"location":"tutorial/models_and_attributes/#attributes","text":"The Customer table of the e-commerce schema has two columns: customer_id customer_name And the Order table has three columns: order_id customer_id order_date In order to add definitions for these columns in the manifest, we need to define Attributes for the customer and order models corresponding to these columns. Attributes for a model are defined at $.models[*].attributes in the Manifest; i.e, within the attributes field for a model. Like datastores and models, each attribute is defined with a key which will be the ID for the Attribute and value as the Attribute Definition . dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"root\" , \"password\" : \"password\" } } }, \"models\" : { \"customer\" : { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"attributes\" : { \"customerId\" : {}, \"customerName\" : {} } }, \"order\" : { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"attributes\" : { \"orderId\" : {}, \"customerId\" : {}, \"orderDate\" : {} } } } } We will be now be adding value definitions for the attributes above. \u27a1 Next: Attribute Value Definition","title":"Attributes"},{"location":"tutorial/multifile_manifest/","text":"Multi-File Manifest If we were to define all the models in a single Manifest like we have done so far, we can see how the manifest will soon become large and unreadable for larger schemas. To overcome this, Dore allows you to split the manifest across multiple files. Each Model , Datastore , and Attribute definition can be stored in a different file. Typically, you would want to move each Model and Datastore definition to a separate file. You can choose to move attributes to separate files as well in case the model file itself starts getting large and unreadable. Let's move the ecommerce datastore definition and the customer and order model definitions different files. The contents of these files are shown below. Ecommerce datastore Let's move the ecommerce datastore definition, i.e, everything at $.datastores['ecommerce'] , in our manifest to a new file ecommerce-datastore.json . ecommerce-datastore.json { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"{{mysql-user}}\" , \"password\" : \"{{mysql-password}}\" } } Customer model Similarly, let's move the customer model definition, i.e, everything at $.models['customer'] , in our manifest to a new file customer-model.json . customer-model.json { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"properties\" : { \"tableName\" : \"Customer\" } , \"attributes\" : { \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"faker\" : { \"uuid4\" : {} } } } , \"customerName\" : { \"properties\" : { \"columnName\" : \"customer_name\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"faker\" : { \"name\" : {} } } } } } Order model Next, let's move the order model definition, i.e, everything at $.models['order'] , to a new file order-model.json order-model.json { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"properties\" : { \"tableName\" : \"Order\" } , \"attributes\" : { \"orderId\" : { \"properties\" : { \"columnName\" : \"order_id\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"faker\" : { \"uuid4\" : {} } } } , \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"ref\" : \"customer.customerId\" } } , \"orderDate\" : { \"properties\" : { \"columnName\" : \"order_date\" , \"columnType\" : \"DATE\" } , \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } } Adding file references in Manifest Finally, let's add references to the files above in our manifest. The new manifest should look like the one shown below: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"ref\" : \"/abs/path/to/ecommerce-datastore.json\" } }, \"models\" : { \"customer\" : { \"ref\" : \"/abs/path/to/customer-model.json\" }, \"order\" : { \"ref\" : \"/abs/path/to/order-model.json\" } } } Invoke Dore Let's invoke Dore in the same way as we did previously with the manifest above to ensure everything is working as expected: dore --manifest /abs/path/to/ecommerce-dore-manifest.json \\ --mysql-user = root \\ --mysql-password = password \\ --drop-conflicting-models We should be able to see a successful run again. \u27a1 Next : Conclusion","title":"Multi-File Manifest"},{"location":"tutorial/multifile_manifest/#multi-file-manifest","text":"If we were to define all the models in a single Manifest like we have done so far, we can see how the manifest will soon become large and unreadable for larger schemas. To overcome this, Dore allows you to split the manifest across multiple files. Each Model , Datastore , and Attribute definition can be stored in a different file. Typically, you would want to move each Model and Datastore definition to a separate file. You can choose to move attributes to separate files as well in case the model file itself starts getting large and unreadable. Let's move the ecommerce datastore definition and the customer and order model definitions different files. The contents of these files are shown below.","title":"Multi-File Manifest"},{"location":"tutorial/multifile_manifest/#ecommerce-datastore","text":"Let's move the ecommerce datastore definition, i.e, everything at $.datastores['ecommerce'] , in our manifest to a new file ecommerce-datastore.json . ecommerce-datastore.json { \"protocol\" : \"mysql\" , \"properties\" : { \"database\" : \"Dore_Ecommerce\" , \"host\" : \"127.0.0.1\" , \"port\" : \"3306\" , \"user\" : \"{{mysql-user}}\" , \"password\" : \"{{mysql-password}}\" } }","title":"Ecommerce datastore"},{"location":"tutorial/multifile_manifest/#customer-model","text":"Similarly, let's move the customer model definition, i.e, everything at $.models['customer'] , in our manifest to a new file customer-model.json . customer-model.json { \"datastore\" : \"ecommerce\" , \"records\" : 10 , \"properties\" : { \"tableName\" : \"Customer\" } , \"attributes\" : { \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"faker\" : { \"uuid4\" : {} } } } , \"customerName\" : { \"properties\" : { \"columnName\" : \"customer_name\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"faker\" : { \"name\" : {} } } } } }","title":"Customer model"},{"location":"tutorial/multifile_manifest/#order-model","text":"Next, let's move the order model definition, i.e, everything at $.models['order'] , to a new file order-model.json order-model.json { \"datastore\" : \"ecommerce\" , \"records\" : 100 , \"properties\" : { \"tableName\" : \"Order\" } , \"attributes\" : { \"orderId\" : { \"properties\" : { \"columnName\" : \"order_id\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"faker\" : { \"uuid4\" : {} } } } , \"customerId\" : { \"properties\" : { \"columnName\" : \"customer_id\" , \"columnType\" : \"CHAR(50)\" } , \"value\" : { \"ref\" : \"customer.customerId\" } } , \"orderDate\" : { \"properties\" : { \"columnName\" : \"order_date\" , \"columnType\" : \"DATE\" } , \"value\" : { \"faker\" : { \"date_between\" : { \"start_date\" : \"-1y\" } } } } } }","title":"Order model"},{"location":"tutorial/multifile_manifest/#adding-file-references-in-manifest","text":"Finally, let's add references to the files above in our manifest. The new manifest should look like the one shown below: dore-ecommerce-manifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"id\" : \"ecommerce-example\" , \"datastores\" : { \"ecommerce\" : { \"ref\" : \"/abs/path/to/ecommerce-datastore.json\" } }, \"models\" : { \"customer\" : { \"ref\" : \"/abs/path/to/customer-model.json\" }, \"order\" : { \"ref\" : \"/abs/path/to/order-model.json\" } } }","title":"Adding file references in Manifest"},{"location":"tutorial/multifile_manifest/#invoke-dore","text":"Let's invoke Dore in the same way as we did previously with the manifest above to ensure everything is working as expected: dore --manifest /abs/path/to/ecommerce-dore-manifest.json \\ --mysql-user = root \\ --mysql-password = password \\ --drop-conflicting-models We should be able to see a successful run again. \u27a1 Next : Conclusion","title":"Invoke Dore"},{"location":"tutorial/overview/","text":"Overview This tutorial is aimed at helping you get started with Dore and start incorporating it in your own workflows. Over the course of this tutorial, we will learn how to use Dore to generate fake data in a MySQL server for an e-commerce database. \u27a1 Next : The E-Commerce Schema","title":"Overview"},{"location":"tutorial/overview/#overview","text":"This tutorial is aimed at helping you get started with Dore and start incorporating it in your own workflows. Over the course of this tutorial, we will learn how to use Dore to generate fake data in a MySQL server for an e-commerce database. \u27a1 Next : The E-Commerce Schema","title":"Overview"}]}